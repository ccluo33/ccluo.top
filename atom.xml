<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ccluo&#39;s Blog</title>
  
  <subtitle>good good study, day day up!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-27T03:39:33.714Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ccluo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML和CSS(八)</title>
    <link href="http://yoursite.com/2019/02/26/HTML%E5%92%8CCSS(%E4%B8%83)/"/>
    <id>http://yoursite.com/2019/02/26/HTML和CSS(七)/</id>
    <published>2019-02-26T15:15:53.000Z</published>
    <updated>2019-02-27T03:39:33.714Z</updated>
    
    <content type="html"><![CDATA[<p>如何利用<code>&lt;style&gt;</code>元素给某种元素增加样式<br>利用样式表给多个页面增加样式<br>继承与覆盖继承<br>利用类为单独的段落指定样式<br>CSS验证工具以及常用属性<br>在CSS中写注释，只需要把注释包围在/*和/*之间。<br><a id="more"></a><br>这几天一直在纠结要考研吗(ಥ﹏ಥ)，有点没有勇气。</p><h1 id="给某种元素增加样式"><a href="#给某种元素增加样式" class="headerlink" title="给某种元素增加样式"></a>给某种元素增加样式</h1><p>比如说给<code>&lt;p&gt;</code>元素增加背景色和边框：<code>p    {   background-color: red; border: 1px solid gray;   }</code>，这为<code>&lt;p&gt;</code>元素增加了红色的背景色以及粗细为1像素，灰色，实线的边框。<br><br>然后要将上述CSS放入HTML。要为HTML直接增加CSS样式，需要在<code>&lt;head&gt;</code>元素中增加开始和结束style标记。CSS规则要放在<code>&lt;style&gt;</code>元素之间。<br><br>如果要改变段落中文本的颜色，CSS规则将写为<code>p  { color: red; }</code>，改变字体颜色的属性名为color。<strong>在改变了段落的文本颜色之后，其中链接的颜色不会发生改变</strong>。<br><br>典型的CSS规则包括一个选择器，以及一个或多个属性和值。通过逗号分隔元素名，可以一次选择多个元素。CSS允许你指定各种选择器，来确定将样式应用到哪些元素。比如说：<code>h1,h2 { font-family: sans-serif; color: gray; }</code>，使用font-family属性指定字体。<br><br>一般来说，要把元素的所有共同样式归组在一起，然后把一个元素特定的样式写在另一个规则中。<br><br>下边框与下划线的区别：如果使用border-bottom属性增加下边框，这条线会延伸到页面边缘。而使用属性text-decoration，并使其值为”underline”时给文本增加下划线，下划线只出现在文本的下面。<br></p><h1 id="给多个页面增加同样的样式"><a href="#给多个页面增加同样的样式" class="headerlink" title="给多个页面增加同样的样式"></a>给多个页面增加同样的样式</h1><p>可能首先会想到，将一个样式复制到其它页面中。不过这样太麻烦了，如果样式发生改变，就必须要对每个页面进行修改，这样既浪费时间而且还容易产生错误。<br><br>此时可以对每个页面链接同一个CSS文件，我们通常把CSS文件称为“样式表”(stylesheets)。<strong>可以分两步进行：先写好CSS文件，然后再对各个页面链接该CSS文件。</strong><br>    <ol><br>        <li>CSS文件的后缀名为css，其内容是将原来<code>&lt;style&gt;</code>标记中的内容复制过来，注意不要复制<code>&lt;style&gt;</code>和<code>&lt;/style&gt;</code>标记，因为”xxx.css”文件只包含CSS，不能包含HTML。</li><br>        <li>然后要从各个页面链接到外部样式表。利用HTML中的<code>&lt;link&gt;</code>元素告诉浏览器，它要利用外部样式表为这个页面增加样式。此时不再需要<code>&lt;style&gt;</code>元素，要将它删除掉。</li><br>    </ol><br><code>&lt;link&gt;</code>元素该怎么写？举个例子：<code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;lounge.css&quot;&gt;</code>，使用<code>&lt;link&gt;</code>元素“链入”外部信息。type属性指定类型，这个信息的类型是”text/css”。换句话说，这是一个CSS样式表。在HTML5中，不再需要这个属性（这是可选的），不过在比较老的页面还是会看到它。rel属性指定了HTML文件与所链接的文件之间的关系。我们要链接到一个样式表，所以这里使用值”stylesheet”。样式表放在href中（在这个例子中，我们使用了相对链接，不过这也可以是一个完整的URL）。需要注意的是<code>&lt;link&gt;</code>元素是一个void元素，它没有结束标记。</p><h1 id="继承与覆盖继承"><a href="#继承与覆盖继承" class="headerlink" title="继承与覆盖继承"></a>继承与覆盖继承</h1><p>元素可以从它们的父元素继承样式。但是不是所有样式都能继承。只有一部分能继承，如font-family。<br><br>可能会产生一个疑问，CSS中哪些属性可以继承，哪些属性不能继承？ 一般来讲，如果样式会影响你的文本外观，所有这些样式都能继承，如字体颜色（color属性），font-family（字体系列）以及所有与字体相关的属性，如font-size（字体大小），font-weight（字体粗细）和font-style（是否斜体）。其他属性不能继承，如边框，这是有道理的。比如说，如果<code>&lt;body&gt;</code>元素有一个边框，这并不表示你希望体中的所有元素都有边框。<br>如果没有继承规则的存在，如果对一个段落应用了某种CSS规则，就需要对一个段落中的每一个内联元素增加CSS规则。<br><br>如果要为整个页面设置某种样式，可以利用继承规则对<code>&lt;body&gt;</code>元素设置该样式，从而是整个页面使用该样式。<br><br>如果对某个元素单独指定了某种CSS规则，则这将覆盖它继承得到的CSS规则（覆盖继承的前提是同一属性）。对于CSS，总会使用最特定的那个规则。所以，如果对<code>&lt;body&gt;</code>有一个规则，对<code>&lt;em&gt;</code>元素有一个更特定的规则，它就会使用这个更特定的规则。<br></p><h1 id="为单独的段落指定样式"><a href="#为单独的段落指定样式" class="headerlink" title="为单独的段落指定样式"></a>为单独的段落指定样式</h1><p>这需要引入类(class)的概念。结合HTML和CSS，我们可以定义一类元素，并对属于该类的所有元素应用样式。<br><br>创建一个类有两步：首先，为HTML中的元素增加一个class属性，这样会把元素增加到这个类中；其次，在CSS中选择这个类。<br><br>    <ol><br>        <li>要将一个元素加入一个类，只需要增加属性”class”，并提供类名。</li><br>        <li>然后要提供一些规则，为这个类的元素指定样式。</li><br>    </ol><br>要在CSS中创建一个类，并选择这个类中的一个元素，可以编写一个类选择器，比如说<code>p.greentea { color: green; }</code>，先选择这个类中的元素，在这里就是元素p。再用一个”.”指定一个类。最后是类名。选择器p.greentea会选择greentea类中的所有段落。<br><br>如果希望类中的两个元素使用相同样式，可以使用逗号分隔选择器，比如说：<code>blockquote.greentea, p.greentea { color: green; }</code>。<br><br>如果希望greentea类中的所有元素都有同一种样式，可以这样写规则：<code>.greentea { color: green; }</code>。如果省略所有元素名，只有一个点，后面是类名，那么这个规则会应用到这个类的所有成员。<br><br>并且，元素可以加入多个类。一个元素要加入多个类，比如说指定一个<code>&lt;p&gt;</code>元素属于greentea,raspberry和blueberry类。可以在开始标记中这样写：<code>&lt;p class=&quot;greentea raspberry blueberry&quot;&gt;</code>。即把各个类名放在class属性中，各个类名之间用一个空格分割。类名的顺序并不重要。如果希望一个元素拥有不同类中定义的不同样式，就要使用多个类。<br><br>如果出现多个选择器选择一个元素并且它们都定义了该元素的某种属性的情况，此时一个规则比其他规则更特定，它就会胜出。比如说类比段落特定，类中的特定元素比类特定。不过还有可能这些规则的特定程度是相同的，由于两个选择器有相同的特定性而无法解决冲突，就要利用样式表文件中规则的顺序来解决问题，这些规则中哪个规则在样式表的最后面哪个就会起作用。<br></p><h1 id="CSS验证工具"><a href="#CSS验证工具" class="headerlink" title="CSS验证工具"></a>CSS验证工具</h1><p>如果你的CSS里有错误，通常这个错误以下的所有其它规则都会被忽略。<br><br>CSS的验证工具为<a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="noopener">http://jigsaw.w3.org/css-validator/</a>。</p><h1 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h1><p><ul><br>    <li>color: 设置文本元素的字体颜色</li><br>    <li>font-weight: 控制文本的粗细，可用它来设置粗体</li><br>    <li>left: 指定一个元素的左边所在位置</li><br>    <li>line-height: 设置一个文本元素的行间距</li><br>    <li>top: 控制元素顶部的位置</li><br>    <li>background-color: 控制元素的背景颜色</li><br>    <li>border: 在一个元素周围加边框。可以有一个实线边框，凸起边框，虚线边框等</li><br>    <li>padding: 内边距设置，使一个元素边缘和它的内容之间有空间</li><br>    <li>font-size: 设置文本大小</li><br>    <li>text-align: 将文本左对齐，居中或右对齐</li><br>    <li>letter-spacing: 在字母之间设置边距</li><br>    <li>font-style: 设置斜体文本</li><br>    <li>list-style: 可用来改变列表中列表项的外观</li><br>    <li>background-image: 在元素后面放置一个图像</li><br></ul></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>CSS包含一些简单语句，称为规则。</li><li>每个规则为选择的一些HTML元素提供样式。</li><li>典型的规则包括一个选择器，以及一个或多个属性和值。</li><li>选择器指定规则将应用到哪些元素。</li><li>每个属性声明以一个分号结束。</li><li>规则中的所有属性和值都放在{}大括号之间。</li><li>可以使用元素名作为选择器，来选择任意元素。</li><li>通过逗号分隔元素名，可以一次选择多个元素。</li><li>要在HTML中包含一个样式，最容易的办法就是使用<code>&lt;style&gt;</code>标记。</li><li>对于HTML以及相当复杂的网站，可能要链接到一个外部样式表。</li><li><code>&lt;link&gt;</code>元素用于包含一个外部样式表。</li><li>很多属性都能继承。例如，如果为<code>&lt;body&gt;</code>元素设置了一个可继承的属性，那么<code>&lt;body&gt;</code>的所有子元素都会继承这个属性。</li><li>通过为你想改变的元素创建一个更特定的规则，能覆盖该元素继承的属性。</li><li>可以使用class属性将元素增加到一个类。</li><li>通过在元素名和类名之间加一个”.”，可以选择该类中的一个特定元素。</li><li>使用”.classname”可以选择属于这个类的所有元素。</li><li>通过在class属性中放入多个类名，可以指定一个元素属于多个类，类名之间用空格分割。</li><li>可以使用W3C验证工具验证CSS(<a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="noopener">http://jigsaw.w3.org/css-validator/</a>)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何利用&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;元素给某种元素增加样式&lt;br&gt;利用样式表给多个页面增加样式&lt;br&gt;继承与覆盖继承&lt;br&gt;利用类为单独的段落指定样式&lt;br&gt;CSS验证工具以及常用属性&lt;br&gt;在CSS中写注释，只需要把注释包围在/*和/*之间。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML和CSS(六)</title>
    <link href="http://yoursite.com/2019/02/26/HTML%E5%92%8CCSS(%E5%85%AD)/"/>
    <id>http://yoursite.com/2019/02/26/HTML和CSS(六)/</id>
    <published>2019-02-26T00:38:57.000Z</published>
    <updated>2019-02-27T00:55:01.439Z</updated>
    
    <content type="html"><![CDATA[<p>HTML版本说明<br><code>&lt;img&gt;</code>元素的alt属性是必要的<br>字符编码<br>W3C验证工具<br><a id="more"></a><br>明天就可以学CSS啦！</p><h1 id="HTML标准及其他"><a href="#HTML标准及其他" class="headerlink" title="HTML标准及其他"></a>HTML标准及其他</h1><h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><p>为了是浏览器显示正确的HTML，需要告诉浏览器自己在使用哪个版本的HTML，并且要确保自己的页面没有任何错误。（可能有错误发生时在一些浏览器上的显示会与其他浏览器不同）。<br><br>可以用一个doctype告诉浏览器你正在使用的HTML版本，这个“标记”要放在HTML文件的最上面。<br><br>HTML5 doctype为<code>&lt;!doctype html&gt;</code>（这相比较HTML的前几个版本较为简单）。<br><br>可能会疑惑HTML5的doctype中都没有体现出版本5啊？是因为现在的HTML标准已经变成了一个“活的标准”，这意味着它会根据需要继续发展和变化，不过不再有固定的版本号了。也就是说，当浏览器看到：<code>&lt;!doctype html&gt;</code>，它就认为你在使用标准HTML。<br><br>HTML的新的“活标准”的关键是向后兼容性。向后兼容性(backwards compatibility)表示我们可以继续向HTML中增加新的内容，浏览器（最终）会支持这个新内容，不过它们还会继续支持原来的内容。所以，今天写的HTML页面将继续正常工作，甚至以后增加了新的特性之后也仍然能很好地工作。<br></p><h2 id="W3C验证工具"><a href="#W3C验证工具" class="headerlink" title="W3C验证工具"></a>W3C验证工具</h2><p>要得到这个验证工具，只需要将浏览器指向<a href="http://validator.w3.org" target="_blank" rel="noopener">http://validator.w3.org</a>。</p><h2 id="增加一个-lt-meta-gt-指定字符编码"><a href="#增加一个-lt-meta-gt-指定字符编码" class="headerlink" title="增加一个&lt;meta&gt;指定字符编码"></a>增加一个<code>&lt;meta&gt;</code>指定字符编码</h2><p>字符编码为我们提供了一种方法，可以在计算机上表示某种语言中的所有字幕，数字和其它符号。<br><br>如今字符编码的标准已经统一为Unicode字符编码。采用Unicode，一种编码就可以表示所有语言。不过，由于还存在其它编码，所以我们还需要告诉浏览器我们在使用Unicode（或者你选择的另外一种编码）。要为Web页面指定Unicode，需要在HTML中加一个<code>&lt;meta&gt;</code>标记：<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>。”meta”表示我们要告诉浏览器关于页面的一些信息。就像其它HTML标记一样，<code>&lt;meta&gt;</code>标记也有一些属性。要在charset属性中指定字符编码，charset属性值就是我们使用的字符编码类型。”utf-8”是Unicode系列中的一个编码（这个系列还有很多其它编码）。Web页面中使用的就是”utf-8”。<br><br><code>&lt;meta&gt;</code>标记放在<code>&lt;head&gt;</code>元素中（因为<code>&lt;head&gt;</code>包含有关页面的信息），而且还要注意，<code>&lt;meta&gt;</code>标记这一行要增加到<code>&lt;head&gt;</code>元素中所有其他元素的上面。<br></p><h2 id="HTML知识点补充"><a href="#HTML知识点补充" class="headerlink" title="HTML知识点补充"></a>HTML知识点补充</h2><ul><li>只有<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>元素能直接放在<code>&lt;html&gt;</code>元素中。这说明，所有其他元素都必须放在<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>元素中。没有例外！</li><li>一定要在<code>&lt;head&gt;</code>元素中包含一个<code>&lt;title&gt;</code>元素。这是雷打不动的原则。如果没有做到，则会得到不符合标准的HTML。只能在<code>&lt;head&gt;</code>元素中放置<code>&lt;title&gt;</code>，<code>&lt;meta&gt;</code>和<code>&lt;style&gt;</code>元素。</li><li>嵌套某些元素要当心。比如说：不要把<code>&lt;a&gt;</code>元素嵌在另一个<code>&lt;a&gt;</code>元素中，因为这样会让访问者很迷惑。另外，不允许在<code>&lt;img&gt;</code>等void元素中嵌套其他内联元素。</li><li>注意要检查属性！有些元素属性是必要的，有些则是可选的。例如，如果<code>&lt;img&gt;</code>元素没有src属性，就没有什么意义，而且<strong><code>&lt;img&gt;</code>元素的alt属性也是必要的</strong>。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>HTML5是当前的HTML标准。</li><li>万维网协会(World Wide Web Consortium,W3C)是定义HTML标准的标准组织。</li><li>文档类型定义(doctype)用来告诉浏览器你使用的HTML版本。</li><li>HTML标准现在是一个“活的标准”，这说明这个标准会不断改变，加入新的特性和更新。</li><li><code>&lt;head&gt;</code>元素中的<code>&lt;meta&gt;</code>标记告诉浏览器关于一个Web页面的额外信息，如内容类型和字符编码。</li><li><code>&lt;meta&gt;</code>标记的charset属性告诉浏览器Web页面使用的字符编码。</li><li>大多数Web页面的HTML文件都使用utf-8编码，另外<code>&lt;meta&gt;</code>标记的charset属性值通常也是utf-8。</li><li>alt属性是<code>&lt;img&gt;</code>元素中的必要属性。</li><li>W3C验证工具是一个免费的在线服务，可以检查页面是否符合标准。</li><li>可以使用这个验证工具确保你的HTML合法，而且元素和属性符合标准。</li><li>如果遵循标准，则你的页面会更快地显示，而且在不同浏览器中显示时差异会更小，CSS也能更好地工作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML版本说明&lt;br&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;元素的alt属性是必要的&lt;br&gt;字符编码&lt;br&gt;W3C验证工具&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTML和CSS(五)</title>
    <link href="http://yoursite.com/2019/02/24/HTML%E5%92%8CCSS(%E4%BA%94)/"/>
    <id>http://yoursite.com/2019/02/24/HTML和CSS(五)/</id>
    <published>2019-02-24T13:36:17.000Z</published>
    <updated>2019-02-25T01:56:56.869Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器如何处理图像<br><br>缩略图的使用<br><br><code>&lt;img&gt;</code>元素是一个内联元素，这说明浏览器不会在图像前后插入一个换行<br><br><code>&lt;img&gt;</code>元素的src属性和alt属性介绍<br><br>JPEG,PNG,GIF三种图像格式的特点<br><a id="more"></a><br>开学了嘻嘻，这学期不该提前四天就来的，来了之后好无聊，刚来的第一天还找不到饭吃，真让人难受。下学期开学没啥事的话还是来晚一点吧！</p><h1 id="浏览器如何处理图像"><a href="#浏览器如何处理图像" class="headerlink" title="浏览器如何处理图像"></a>浏览器如何处理图像</h1><p>浏览器处理<code>&lt;img&gt;</code>元素与处理其它HTML元素稍有不同。在读取HTML页面之后，浏览器会从服务器获取各个图像并显示。</p><h1 id="图像格式介绍"><a href="#图像格式介绍" class="headerlink" title="图像格式介绍"></a>图像格式介绍</h1><p>Web上最常用的图像格式是这三种：JPEG,PNG和GIF。<br></p><ul><li>照片和复杂图像使用JPEG<br></li><li>单色图像，logo和几何图像使用PNG或GIF<br><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2>它最适合连续色调图像，如照片。<br><br>可以表示包含多达1600万种不同颜色的图像。<br><br>这是一种“有损”格式，因为缩小文件大小时会丢掉图像的一些信息。<br><br>不支持透明度。<br><br>文件比较小，以便Web页面更高效地显示。<br><br>不支持动画。<br><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2>PNG最适合单色图像和线条构成的图像（如logo,剪贴画和图像中的小文本）。<br><br>PNG可以表示包含上百万种不同颜色的图像。PNG有三种：PNG-8，PNG-24和PNG-32，取决于你需要表示多少种颜色。<br><br>PNG会压缩文件来缩小文件大小，不过不会丢掉信息。所以这是一种“无损”格式。<br><br>允许将颜色设置为“透明”，使图像下面的东西可以显示出来。<br><br>与相应的JPEG文件相比，PNG文件更大一些，不过取决于使用的颜色数，可能比相应的GIF文件小，也可能更大。<h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2>类似于PNG，GIF最适合单色图像和线条构成的图像（如logo,剪贴画和图像中的小文本）。<br><br>GIF可以表示最多256种不同颜色的图像。<br><br>GIF也是一种“无损”格式。<br><br>GIF也支持透明度，不过只允许一种颜色设置为“透明”。<br><br>GIF文件往往比相应的JPEG文件大。<br><br>支持动画。</li><li>在GIF和PNG之间如何选择呢？    要在GIF和PNG中做出选择，有几个方面需要考虑。首先，PNG的压缩要稍稍优于GIF，所以对于一个颜色数相同的图像（也就是说，最多256中颜色），PNG文件可能更小一些。不过，如果需要更多颜色而GIF无法提供，而且也不能选择JPEG（例如，需要透明性），那么就只能选择PNG了。不过，如果需要动画的话，那么还得使用GIF，因为GIF是唯一支持动画并得到广泛支持的格式。<h1 id="lt-img-gt-元素"><a href="#lt-img-gt-元素" class="headerlink" title="&lt;img&gt;元素"></a><code>&lt;img&gt;</code>元素</h1></li><li><code>&lt;img&gt;</code>元素是一个内联元素。它在显示时不会在前面或后面插入换行（浏览器总是在块元素前后在垂直方向上显示间距）。</li><li><code>&lt;img&gt;</code>是一个void元素。</li><li>其src属性指定了在Web页面上显示的图像文件的位置。src属性不只是用于相对链接，还可以在src属性中放入URL。对于相同网站上的图像，最好使用相对路径。对于另一个不同网站上的对象，通常要使用这个图像的URL。需要注意的是，与默认Web页面不同，这里没有默认图像之说。</li><li>void元素就是没有内容和结束标记的元素，为什么说<code>&lt;img&gt;</code>元素是void元素，它不是有内容（图像）吗？    更确切地讲，void元素是指HTML页面中在开始标记和结束标记之间没有任何内容的元素。确实，图像也是内容，不过<code>&lt;img&gt;</code>元素只是指向图像。图像并不是HTML页面本身的一部分。实际上，浏览器显示页面时，图像会取代<code>&lt;img&gt;</code>元素。另外需要记住，HTML页面是纯文本，所以图像无法直接作为页面的一部分。它是单独存在的。</li><li><code>&lt;img&gt;</code>元素的alt属性可以为访问者提供一些暗示，告诉他们图像里有什么信息。alt属性需要指定，描述这个图像的一些文本。如果图像未显示，就会使用这个文本来取代它。</li><li><code>&lt;img&gt;</code>元素还有一对属性:width和height。width属性告诉 浏览器在页面中显示图像的宽度，height属性告诉浏览器在页面显示图像的高度。宽度和高度都使用像素数指定。如果没有指定宽度和高度，则浏览器在页面中显示这个图像之前会自动确定图像的大小。如果在HTML中提供了width和height，浏览器在显示图像之前就可以开始建立页面布局。如果没有指定，则浏览器在知道了图像大小之后，通常需要重新调整页面布局。当然，还可以提供比图像实际尺寸更大或更小的宽度或高度值，这样浏览器就会缩放图像来满足所指定的大小。不过在这种情况下，可能最好考虑使用CSS来得到同样的结果。</li><li>浏览器窗口宽度大约为800像素（计算机显示屏是由数百万个称为像素的点组成的），有时候会面临图像太大，需要用户使用滚动条查看。大多数人通常会把浏览器宽度设置为800到1280像素之间。所以一般经验是将图像最大宽度设置为800像素（通过照片编辑应用将图像调整为合适的大小）。</li><li>为什么不直接使用width属性和height属性来调整页面上图像的大小？因为浏览器在缩放图像使之适应页面大小之前，任然需要获取整个大图像。width属性和height属性实际上是帮助浏览器确定要为这个图像预留多大的空间。如果使用这两个属性，则它们应该与图像的实际宽度和高度一致。<h1 id="使用缩略图"><a href="#使用缩略图" class="headerlink" title="使用缩略图"></a>使用缩略图</h1>在网站的某个页面上，如果有许多照片的话，我们经常看到的是每个照片的一个小的缩略图像，然后可以单击这个缩略图来查看更大的图像，其实现的方法为：<br><ol><br>  <li>为缩略图创建一个目录。</li><br>  <li>将照片调整大小，然后保存到第一步所创建的目录下（一般缩略图的名字和原图的名字保持一致）。</li><br>  <li>将页面中的各个<code>&lt;img&gt;</code>元素的src属性设置为照片的缩略版本。</li><br>  <li>增加从各个缩略图到一个新页面的链接，这个新页面中包含相应的大照片（一般先创建一个包含新页面的文件夹，再创建新页面，再从原页面的缩略图链接到新页面，即用<code>&lt;a&gt;</code>元素包围缩略图的<code>&lt;img&gt;</code>元素，<code>&lt;a&gt;</code>元素的href属性为包含大照片页面的链接）。</li><br></ol><br>在用<code>&lt;a&gt;</code>元素包围图像后，鼠标经过图像时，光标会改变，指示你可以单击这个链接图像。大多数情况下,用户都可以通过上下文和鼠标光标了解到一个图像是链接。<br><br>为什么不直接链接到一个大照片而要链接到一个包含大照片的页面？  一般认为直接链接到一个图像并不是一个好的做法，因为通常你需要为所显示的图像提供一些上下文。<h1 id="logo的处理"><a href="#logo的处理" class="headerlink" title="logo的处理"></a>logo的处理</h1>大多数照片编辑应用都会以<strong>背景里的棋盘图案</strong>告诉你这个区域是透明的，为logo选择图形格式时要记住这些。<br><br>如果需要透明背景在设置图片格式时就要选中透明度复选框。用蒙版选项来告诉照片编辑应用使用某种颜色背景在文本周围创建蒙版（默认使用白色背景），即根据背景颜色柔化文本边缘，避免文本周围出现光晕（在Photoshop CS6中蒙版选项为杂边选项）。<br><br>为什么不直接设置logo的背景色为某种颜色，让它与web页面的颜色一致？ 可以这么做，但这有一个缺点：如果Web页面中有其它东西要“透过”logo的透明背景显示出来，倘若logo背景为单色，就无法看到它们了。<br><br>在背景色有很大变化的时候，必须用新的蒙版颜色重新创建PNG。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>如果Web页面上有多个大图像，则可以通过创建图像的缩略图使你的Web页面更可用，下载也更快，缩略图是一些小图像（大图像的缩小版本），用户单击这些缩略图时可以看到原来的大图像。</li><li><code>&lt;img&gt;</code>元素是一个内联元素，这说明浏览器不会在图像前后插入一个换行。</li><li>利用<code>&lt;img&gt;</code>元素的src属性指定图像文件的位置。可以在src属性中使用相对路径包含你自己网站中的图像，或者可以使用URL包含其他网站的图像。</li><li><code>&lt;img&gt;</code>元素的alt属性是对图像的一个有意义的描述。在一些浏览器中，如果无法找到图像，则会显示这个描述，另外屏幕阅读器会使用这个属性为有视力障碍的人描述图像。</li><li>JPEG,PNG和GIF是Web浏览器广泛支持的三种图像格式。JPEG格式最适合保存照片和其它复杂图像。GIF和PNG格式最适合保存logo和其它包含单色，线条或文本的简单图形。</li><li>JPEG图像可以按不同质量压缩，所以可以很好地权衡图像质量和文件大小，来满足你的需要。</li><li>GIF和PNG图像格式允许建立一个有透明背景的图像。如果把一个有透明背景的图像放在一个Web页面中，图像后面的东西（如页面的背景色）就会透过图像的透明部分显示出来。</li><li>GIF和PNG是无损格式，这说明相比于JPEG文件，这些格式的文件往往更大。</li><li>PNG可以提供比GIF更好的透明度控制，而且不像GIF只支持256种颜色，PNG可以支持更多颜色。</li><li>在Photoshop CS6中，使用保存为Web格式对话框中的杂边选项来选择合适的颜色，柔化PNG或GIF图像的边缘。</li><li>图像可以用作指向其它Web页面的链接。要由图像创建一个链接，可以使用<code>&lt;img&gt;</code>元素作为<code>&lt;a&gt;</code>元素的内容，将链接放在<code>&lt;a&gt;</code>元素的href属性中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器如何处理图像&lt;br&gt;&lt;br&gt;缩略图的使用&lt;br&gt;&lt;br&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;元素是一个内联元素，这说明浏览器不会在图像前后插入一个换行&lt;br&gt;&lt;br&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;元素的src属性和alt属性介绍&lt;br&gt;&lt;br&gt;JPEG,PNG,GIF三种图像格式的特点&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTML和CSS(四)</title>
    <link href="http://yoursite.com/2019/01/30/HTML%E5%92%8CCSS(%E5%9B%9B)/"/>
    <id>http://yoursite.com/2019/01/30/HTML和CSS(四)/</id>
    <published>2019-01-30T14:17:42.000Z</published>
    <updated>2019-02-18T12:58:53.185Z</updated>
    
    <content type="html"><![CDATA[<p>URL中协议部分告诉浏览器应当使用什么方法来获取资源（大多数情况下，协议都是HTTP）。网站部分（由服务器名和域名组成）告诉浏览器要从互联网上的哪个计算机获取资源。最后绝对路径告诉服务器我们要找哪个页面。<br>使用URL或者相对链接链接到其它页面，结合id属性，然后再加上#可以链接到Web页面的指定位置。<br>还可以在<code>&lt;a&gt;</code>元素中使用title属性对链接进行描述。<br>在<code>&lt;a&gt;</code>元素中使用target属性控制浏览器如何打开一个窗口。<br><a id="more"></a><br>这几天太懒了。</p><h1 id="将Web页面发布到互联网上"><a href="#将Web页面发布到互联网上" class="headerlink" title="将Web页面发布到互联网上"></a>将Web页面发布到互联网上</h1><p>我们需要做这几件事情</p><p><ol><br>    <li>找一家托管公司。</li><br>    <li>为你的网站选一个名字（比如www.starbuzzcoffee.com）。</li><br>    <li>想办法把文件从你的计算机上传到托管公司的服务器上（这样的方法有很多）。</li><br>    <li>然后就可以把你的新网站告诉别人了！</li><br></ol></p><h2 id="选择托管公司要考虑以下几点："><a href="#选择托管公司要考虑以下几点：" class="headerlink" title="选择托管公司要考虑以下几点："></a>选择托管公司要考虑以下几点：</h2><p><ul><br>    <li>技术支持：这家托管公司有没有一个好的系统来处理你的技术问题？比较好的公司会通过电话或邮件对你的问题迅速作出回应。</li><br>    <li>数据传输：这是托管公司允许你在一定时间内向访问者发送的页面和数据量。大多数托管公司可能会为小网站提供最基本的方案，这些方案中提供的数据传输量并不大。如果你要创建的网站可能有大量访问者，就要仔细考虑这个方面。</li><br>    <li>备份：这家托管公司是否会定期对你的页面和数据做备份，从而在服务器出现硬件故障时能够恢复？</li><br>    <li>域名：托管公司定价中是否包含一个域名？</li><br>    <li>可靠性：大多数托管公司都声称保证网站99%以上的时间内都能正常运行。</li><br>    <li>赠品：是否附送了其他赠品，比如Email地址，论坛或脚本语言支持？</li><br></ul></p><h2 id="域名是什么"><a href="#域名是什么" class="headerlink" title="域名是什么?"></a>域名是什么?</h2><p>比如说：对于网站名：<code>www.starbuzzcoffee.com</code>，其中<code>starbuzzcoffee.com</code>部分就是一个域名。不同的域结尾有不同的用途：<code>.com</code>,<code>.org</code>,<code>.gov</code>,<code>.edu</code>。另外还可以表示不同国家：<code>.co.uk</code>,<code>.co.jp</code>等选择一个域时，要选择最适合自己的。<code>www</code>部分是域中一个特定服务器的名字。可以创建使用相同域名的其它网站，也就是说<strong>域名可以用于多个网站</strong>。购买域名就像买下一块地，在这块地上，可以随自己所愿创建很多网站。 </p><h2 id="把自己的文件复制到服务器的根文件夹"><a href="#把自己的文件复制到服务器的根文件夹" class="headerlink" title="把自己的文件复制到服务器的根文件夹"></a>把自己的文件复制到服务器的根文件夹</h2><p>要知道你的根文件夹在服务器的什么位置，然后再把你自己的文件复制到这里。<br><br>需要使用FTP(File Transfer Protocol，文件传输协议)将文件传输到Web。有些FTP应用是命令行的，有些有完备的图形界面，还有一些甚至内置于Dreamweaver和Expression Web之类的应用中。它们都使用相同的命令，不过有些应用要求你自己输入命令，而另外一些允许你使用图形界面。FTP的工作过程如下所示：</p><p></p><p><br>    <ol><br>        <li>首先，使用FTP连接到你的服务器。要完成连接，需要托管公司提供的一个用户名和口令。比如说输入<code>ftp www.starbuzzcoffee.com</code>请求连接然后连接成功再输入用户名和口令登录。</li><br>        <li>使用”cd”命令把服务器当前目录切换到文件传输的目标目录。</li><br>        <li>使用<code>put</code>命令将文件上传到服务器。</li><br>        <li>还可以用<code>mkdir</code>命令在服务器上创建一个新目录（也就是新建一个文件夹）。</li><br>        <li>还可以使用<code>get</code>命令获取文件，把一个文件的副本从服务器传回你的计算机。</li><br>    </ol><br></p><br>不论我们是在命令行上输入FTP命令，还是使用一个有图形界面的FTP应用，执行的命令或操作基本上都是一样的。常用的FTP命令有：<p></p><p></p><p><br>    <ul><br>        <li>dir：得到当前目录的文件列表。</li><br>        <li>cd：切换到另一个目录。”..”也表示上一层目录。</li><br>        <li>pwd：显示当前目录。</li><br>        <li>put <filename>：将指定的文件传送到服务器。</filename></li><br>        <li>get <filename>：从服务器获取指定的文件，传回你的计算机。</filename></li><br>    </ul><br></p><br>对于小型的网站，通常需要在自己的计算机上编辑文件，然后每次想要更新网站时都要上传这些文件。在向服务器上传文件之前，可以用自己的计算机测试自己做的修改，确保一切都能正常工作。对于比较大的网站，通常会创建一个测试网站和一个真实网站，这样在转向真实网站之前，可以先在测试网站上预览修改的结果。如果使用的是类似Dreamweaver或Coda等工具，则这些工具允许我们在自己的计算机上测试所做的修改，当我们保存文件时，文件会自动传送到网站。<p></p><h2 id="URL-Uniform-Resource-Locators，统一资源定位符"><a href="#URL-Uniform-Resource-Locators，统一资源定位符" class="headerlink" title="URL(Uniform Resource Locators，统一资源定位符)"></a>URL(Uniform Resource Locators，统一资源定位符)</h2><p>在浏览器中输入的Web地址就是URL，下面来剖析一个URL:<code>http://www.starbuzzcoffee.com/index.html</code>，URL的第一部分<code>http</code>指出了获取资源的协议，第二部分<code>www.starbuzzcoffee.com</code>是网站名，第三部分<code>index.html</code>是从根文件夹到资源的绝对路径。我们用“/”表示根文件夹。<br><br>统一资源定位符是一个全局地址，可以用来定位Web上的任意资源，包括HTML页面，音频，视频和许多其他形式的Web内容。除了指定资源的位置，URL还可以用来指定获取资源的协议。<br><br>还有这种形式的URL:<code>http://www.mydomain.com:8000/index.html</code>，<code>:8000</code>是一个可以放在HTTP URL中的可选的“端口”。可以这样来考虑端口：网站名就像一个地址，端口则像是这个地址的邮箱号（例如，在一个复和公寓里）。通常Web上的所有东西都会传送到一个默认端口（80），不过有时Web服务器会配置为在另外一个不同的端口接收请求（如8000）。这种情况经常在测试服务器上出现。正常的Web服务器几乎都在端口80接收请求。如果你没有指定端口，则默认为80。</p><h2 id="HTTP-HyperText-Transfer-Protocol，超文本传输协议"><a href="#HTTP-HyperText-Transfer-Protocol，超文本传输协议" class="headerlink" title="HTTP(HyperText Transfer Protocol，超文本传输协议)"></a>HTTP(HyperText Transfer Protocol，超文本传输协议)</h2><p>HTTP是在Web上传输超文本文档的公认的一种方法（协议）。尽管“超文本文档”通常只是指HTML页面，但这个协议还可以用来传输图像或Web页面可能需要的任何其他文件。<br>HTTP是一个简单的请求和响应协议。其工作方式如下：<br></p><ul><li>在找得到资源的情况下：<br><img src="images/http1.jpg" alt=""></li><li>如果无法找到资源，则服务器会向浏览器报告我们熟悉的“404错误”：<br><img src="images/http2.jpg" alt=""><br>还有其它的协议！<br><br>浏览器从你的计算机本地读取文件时会使用file协议。如果你想输入一个文件URL，则要注意重要的一点是与HTTP不同，文件URL有3个斜线而不是2个。比如说<code>file:///chapter4/starbuzz/index.html</code>。可以这样来记：如果删去一个HTTP URL中的网站名，那么也会有三个斜线。<h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2>绝对路径总是从根”/“开始，加上导航到文件所经过的每一个文件夹，文件夹名之间加一个”/“来分割，然后再加上文件名。<br><br>在我们以前学<code>&lt;a&gt;</code>元素时其href属性中我们放入的是相对路径。在单击一个相对链接时，在后台浏览器会根据这个相对路径和所单击页面的路径创建一个绝对路径。所以，所有Web服务器看到的都是绝对路径，这要归功于浏览器。<h2 id="默认页面"><a href="#默认页面" class="headerlink" title="默认页面"></a>默认页面</h2>我们还会碰到一种情况：如果浏览器向Web服务器请求一个目录而不是文件时会发生什么？比如说请求服务器根目录中的images目录：<code>http://www.starbuzzcoffee.com/images/</code>。<br><br>Web服务器接收到一个类似这样的请求时，它会尝试查找这个目录中的一个默认文件。通常默认文件名为”index.html”或”default.htm”，如果服务器找到这样一个文件，就会把它返回给浏览器显示。<br><br>所以，要从根目录（或任何其他目录）默认地返回一个文件，只需把这个文件命名为”index.html”或”default.htm”。至于命名为两者当中的哪一个这就需要了解你的托管公司希望你如何命名默认文件，因为这取决于他们使用哪种类型的服务器。<br><br>如果服务器接收到这样一个末尾没有”/“的请求，而且这个目录确实存在，服务器就会帮你加上末尾的斜线。所以如果服务器接收到以下请求：<br><br><code>http://www.starbuzzcoffee.com</code><br><br>它会把这个请求改为<br><br><code>http://www.starbuzzcoffee.com/</code><br><br>这会让服务器查找一个默认文件，最后会返回这个文件，就好像你之前输入了以下地址：<br><br><code>http://www.starbuzzcoffee.com/index.html</code><h1 id="如何链接到其他网站？"><a href="#如何链接到其他网站？" class="headerlink" title="如何链接到其他网站？"></a>如何链接到其他网站？</h1>URL并不只是在浏览器中输入，还可以在HTML中使用。要链接到Web上的资源，只需要它的统一资源定位符(URL)，把这个URL放在<code>&lt;a&gt;</code>元素中作为href属性值。<br><br>链接页面有两种方法：相对路径和URL。相对路径只用来链接同一网站内的页面，而URL通常用来链接其他网站。<h2 id="为链接增加标题以便访问"><a href="#为链接增加标题以便访问" class="headerlink" title="为链接增加标题以便访问"></a>为链接增加标题以便访问</h2><code>&lt;a&gt;</code>元素有一个title属性，就是用来提供链接信息的。需要注意的是，<code>&lt;head&gt;</code>中还有一个名为<code>&lt;title&gt;</code>的元素。之所以名字相同，是因为它们本来就是相关的，通常建议title属性值和所链接的Web页面的<code>&lt;title&gt;</code>元素值相同。不过这不是一个严格的要求，在title属性中提供自己的更具体的描述可能更有意义。<br><br>为<code>&lt;a&gt;</code>增加title属性的例子：  <code>Read the &lt;a href=&quot;http://wickedlysmart.com/buzz&quot; title=&quot;Read all about caffeine on the Buzz&quot;&gt;Caffeine Buzz&lt;/a&gt;</code>，其中title元素有一个值，这是所要链接的页面的文本描述。<br><br>在大多数浏览器中，标题会显示为一个工具提示。当把鼠标移动到链接上，停留一秒，就可以看到这个工具提示。<br><br>可以为任何元素增加title属性，所以如果希望某个元素上有一个工具提示，比如一个标题，则可以在<code>&lt;h1&gt;</code>开始标记中增加一个title属性，就像对<code>&lt;a&gt;</code>一样。有些元素不只是使用title属性作为工具提示，可能还有其他用途，不过工具提示是最常见的用法。<br><br>进一步完善链接时要记住以下技巧：<br><br><ul><br>  <li>保证链接标签很简洁。不要把整个句子或大段文字放在链接里。一般来讲，要保证只有几个单词。可以在title属性中提供额外的信息。</li><br>  <li>保证链接标签是有意义的。不要使用类似“单击这里”或“这一页”之类的链接标签（因为这样用户可能只会注意看链接）。</li><br>  <li>不要把链接放在一起，用户将很难区分放在一起的链接。</li><br></ul><h2 id="链接到页面中的某个特定位置"><a href="#链接到页面中的某个特定位置" class="headerlink" title="链接到页面中的某个特定位置"></a>链接到页面中的某个特定位置</h2>到现在，我们知道只要链接到另一个页面，浏览器就会加载整个页面，并从头开始显示。<br><br>实际上，<code>&lt;a&gt;</code>元素可以带一个id属性，允许你直接访问页面中的一个特定点。<br><br>需要先使用id属性为<code>&lt;a&gt;</code>创建目标，然后用id链接到元素。<br><br>可以为任意元素增加id属性，也就是说可以为一个<code>&lt;a&gt;</code>元素增加id属性，即链接到一个链接。<br><h3 id="使用id属性为-lt-a-gt-创建目标"><a href="#使用id属性为-lt-a-gt-创建目标" class="headerlink" title="使用id属性为&lt;a&gt;创建目标"></a>使用id属性为<code>&lt;a&gt;</code>创建目标</h3>id一定要用一个字母开头(A~Z或a~z)，后面可以是任意字母，数字，横线，下划线，冒号或点号。<br><br>可以认为id属性是一种唯一标志元素的方法。带id的元素有一个特殊特性：你可以直接链接这些元素。使用id属性在页面中为<code>&lt;a&gt;</code>创建目标的步骤为：<br><br><ol><br>  <li>找到页面中你希望创建锚点的位置。这可以是页面上的任何文本，不过通常是标题。</li><br>  <li>为目标选择一个标识符名，如”coffee”或”summary”或”bio”，并在元素的开始标记中插入一个id属性。需要注意，id必须是这个页面中唯一的。</li><br></ol><h3 id="如何用id链接到元素"><a href="#如何用id链接到元素" class="headerlink" title="如何用id链接到元素"></a>如何用id链接到元素</h3>不论是相对链接还是URL，要链接到页面中的一个特定目标，只需要在链接最后加一个#，再加上目标标识符。<br><br>特定目标的主要好处是链接到长文件中的某个位置，使得访问者不必向下滚动文件来查找所需的部分。<br><br>比如说链接到index.html的Coffee处： <code>Read the &lt;a href=&quot;http://wickedlysmart.com/buzz/index.html#Coffee&quot; title=&quot;Read all about caffeine on the Buzz&quot;&gt;Caffeine Buzz&lt;/a&gt;</code><br><br>可以在文档中放置一个指向相同文档中某个目标的链接。例如，要链接到同一个页面上的”top”目标，可以写为<code>&lt;a href=&quot;#top&quot;&gt;Back to top&lt;/a&gt;</code>。<br><br>不一定总使用文字作为<code>&lt;a&gt;</code>元素的内容。<code>&lt;a&gt;</code>元素能够由文字和图像（内联内容）创建链接，在HTML5中进一步更新，现在还可以从块元素（如<code>&lt;p&gt;</code>和<code>&lt;blockquote&gt;</code>）创建链接！所以可以用<code>&lt;a&gt;</code>有各种不同内容创建链接。<br><h2 id="使用target打开新窗口"><a href="#使用target打开新窗口" class="headerlink" title="使用target打开新窗口"></a>使用target打开新窗口</h2>要在一个新窗口中打开一个页面，需要告诉浏览器你要打开的窗口名。如果没有告诉浏览器要使用哪个特定的窗口，浏览器就会在同一个窗口中打开这个页面。可以为<code>&lt;a&gt;</code>元素增加一个target属性，告诉浏览器使用一个不同的窗口。target属性值会告诉浏览器页面的”目标窗口“。如果使用<code>_blank</code>作为目标，浏览器就总是打开一个新窗口显示页面。<br><br>举个例子：<code>&lt;a target=&quot;_blank&quot; href=&quot;http://wickedlysmart.com/buzz&quot; title=&quot;Read all about caffeine on the Buzz&quot;&gt;Caffeine Buzz&lt;/a&gt;</code>，其中target属性告诉浏览器在哪里打开href属性中链接指示的Web页面。如果没有target，浏览器就会在同一个窗口中打开这个链接。如果目标为<code>_blank</code>，浏览器就会在一个新窗口中打开链接。<br><br>现在大多数浏览器都有一个默认设置，会在一个标签页中打开新窗口，而不是一个全新的浏览器窗口。不过新的标签页和新窗口实际上是一样的，只是标签页可以共享原窗口的窗口边框。如果想强制打开一个全新的窗口，则大多数浏览器上可以通过首选项设置来实现。<br><br>如果所有<code>&lt;a&gt;</code>元素中的target都指定为”_blank”，那么每个链接都会在一个新的空窗口打开。不过不一定要把target指定为<code>_blank</code>。如果指定另一个名字，如”coffee”，那么有相同目标名”coffee”的所有链接都会在同一个窗口中打开。这是因为，为target指定一个特定的名字时，如”coffee”，实际上就是在对显示链接页面的新窗口命名。<code>_blank</code>则是一种特殊情况，告诉浏览器总是使用一个新窗口。<br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>托管公司可能会为你的域创建一个或多个Web服务器。服务器通常命名为”www”。</li><li>典型的URL由一个协议，一个网站名和资源的一个绝对地址组成。</li><li>浏览器使用file协议从你的计算机读取页面。</li><li>“index.html”和”default.htm”都是默认页面。如果指定一个目录而没有指定文件名，则Web服务器会查找一个默认页面返回到浏览器。</li><li>可以用id属性在页面中创建一个目标。使用#后面增加一个目标id，可以链接到页面中的那个位置。</li><li>为了便于访问，可以在<code>&lt;a&gt;</code>元素中使用title属性提供链接的一个描述。</li><li>使用target属性在另一个浏览器窗口中打开链接。不过对于使用各种不用设备和浏览器的用户，target属性可能会有问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;URL中协议部分告诉浏览器应当使用什么方法来获取资源（大多数情况下，协议都是HTTP）。网站部分（由服务器名和域名组成）告诉浏览器要从互联网上的哪个计算机获取资源。最后绝对路径告诉服务器我们要找哪个页面。&lt;br&gt;使用URL或者相对链接链接到其它页面，结合id属性，然后再加上#可以链接到Web页面的指定位置。&lt;br&gt;还可以在&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素中使用title属性对链接进行描述。&lt;br&gt;在&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素中使用target属性控制浏览器如何打开一个窗口。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTML和CSS(三)</title>
    <link href="http://yoursite.com/2019/01/22/HTML%E5%92%8CCSS(%E4%B8%89)/"/>
    <id>http://yoursite.com/2019/01/22/HTML和CSS(三)/</id>
    <published>2019-01-22T10:26:31.000Z</published>
    <updated>2019-01-30T14:26:00.032Z</updated>
    
    <content type="html"><![CDATA[<p>引用元素<code>&lt;q&gt;</code>和引用元素<code>&lt;blockquote&gt;</code>的区别：<code>&lt;q&gt;</code>是内联元素，适合于小段引用时使用，而<code>&lt;blockquote&gt;</code>是块元素，适合于大段引用。<br>一个列表由两种元素构成：列表类型和列表项。列表类型有无序列表（<code>&lt;ul&gt;</code>元素表示）以及有序列表（<code>&lt;ol&gt;</code>元素表示），列表项由<code>&lt;li&gt;</code>元素表示。这三个元素都是块元素。<br><a id="more"></a><br>再次意识到自己很菜qaq</p><h1 id="认识-lt-q-gt-元素"><a href="#认识-lt-q-gt-元素" class="headerlink" title="认识&lt;q&gt;元素"></a>认识<code>&lt;q&gt;</code>元素</h1><ul><li><code>&lt;q&gt;</code>元素用来在HTML里面添加简短的引用。下面是一小段测试HTML:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Quote Test Drive&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">You never know when you&apos;ll need a good quote, how about &lt;q&gt;To be or not to be&lt;/q&gt;, or &lt;q&gt;Wherever you go, there you are&lt;/q&gt;.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>每个引用都要用一个<code>&lt;q&gt;</code>开始标记和一个<code>&lt;/q&gt;</code>结束标记包围。注意，这里没有在引用周围加双引号。这些引用在浏览器中会如下图这样显示，浏览器会负责加上双引号。<br><img src="images/testq.jpg" alt=""></li><li><strong>并不是所有浏览器都会在<code>&lt;q&gt;</code>元素的内容两边加双引号</strong>。</li><li>使用<code>&lt;q&gt;</code>元素可以使页面更结构化，更有意义。人们在文本中使用双引号原因可能有很多（使用双引号并不代表它确实是引用文字），但是如果使用的是<code>&lt;q&gt;</code>元素，这就意味着这是某种特定的内容，它表示的是一段引用文字。也就是说，通过标记引用，我们可以为它增加更多的含义（并且我们可以对引用设置样式，使它的外观如我们所愿）。<h1 id="很长的引用"><a href="#很长的引用" class="headerlink" title="很长的引用"></a>很长的引用</h1></li><li><code>&lt;q&gt;</code>用于短引用，作为现有段落的一部分。<code>&lt;blockquote&gt;</code>元素用于较长的引用，需要单独显示。</li><li>一个使用<code>&lt;blockquote&gt;</code>的例子如下所示（节选的一部分代码）：</li></ul><pre><code>&lt;h2&gt;July 14, 2012&lt;/h2&gt;&lt;p&gt;  I saw some Burma Shave style signs on the side of the  road today:&lt;/p&gt;&lt;blockquote&gt;  Passing cars,   When you can&apos;t see,   May get you,   A glimpse,   Of eternity. &lt;/blockquote&gt;&lt;p&gt;  I definitely won&apos;t be passing any cars.&lt;/p&gt;</code></pre><p>我们在浏览器中打开后如下所示：<br><img src="images/html3_2.jpg" alt=""></p><ul><li>可以看出<code>&lt;blockquote&gt;</code>创建了一个单独的文本块（与<code>&lt;p&gt;</code>类似），另外还把文字稍微缩进，使它更像一个引用。不过我们的引用与原先预想的还有差距，因为所有行都在一起。我们希望它分行显示。</li><li>如果想引用一段或者多段文字，就要使用<code>&lt;blockquote&gt;</code>，不过如果只想把一个引用放在现有的文字里，作为其中的一部分，就可以使用<code>&lt;q&gt;</code>。</li><li>把段落元素放在<code>&lt;blockquote&gt;</code>中，一个段落元素对应一个段落就可以实现一个块引用中有多段。</li><li><strong>只是有些浏览器显示<code>&lt;blockquote&gt;</code>时会缩进。一些浏览器对于<code>&lt;blockquote&gt;</code>可能不使用缩进。</strong>所以，不要指望<code>&lt;blockquote&gt;</code>在所有浏览器中都有相同的显示。</li><li>引用元素可以结合使用，可以将一个<code>&lt;q&gt;</code>元素放在<code>&lt;p&gt;</code>元素中，同样的，也可以将<code>&lt;q&gt;</code>嵌在<code>&lt;blockquote&gt;</code>中。如果引用某个人的话，而他又引用另外某个人的言论，可能就需要这样的嵌套使用。不过把<code>&lt;blockquote&gt;</code>放在一个<code>&lt;q&gt;</code>元素中似乎没有任何意义。</li><li><code>&lt;blockquote&gt;</code>和<code>&lt;q&gt;</code>实际是两类不同的元素。<code>&lt;blockquote&gt;</code>元素是一个块(block)元素，而<code>&lt;q&gt;</code>元素是一个内联(inline)元素。块元素显示时就好像前后各有一个换行，而内联元素在页面文本流中总在“行内”出现。</li><li>块元素特立独行，内联元素随波逐流。<code>&lt;h1&gt;,&lt;h2&gt;,...&lt;h6&gt;,&lt;p&gt;</code>和<code>&lt;blockquote&gt;</code>都是块元素，每个块元素都单独显示，就好像前后都有换行。块元素的内容分块显示。<code>&lt;q&gt;,&lt;a&gt;</code>和<code>&lt;em&gt;</code>是内联元素。<code>&lt;q&gt;</code>则不同，与所有元素一样，<code>&lt;q&gt;</code>会显示在所在的段落中。</li><li>块元素通常用作Web页面中的主要构建模块，而内联元素往往用来标记小段内容。设计一个页面时，一般先从较大的块开始（块元素），然后在完善页面时再加入内联元素。</li><li>为什么在上面的图片中引用的文字不能分行显示呢？浏览器不会显示空白符和换行！！！可以考虑把每一行都放在一个块元素中。但是实际上HTML中提供了元素进行换行操作——<code>&lt;br&gt;</code>元素！在希望换行的地方增加一个<code>&lt;br&gt;</code>元素，这里就会插入一个“换行符”。</li><li><code>&lt;br&gt;</code>元素是一个没有任何内容的元素，因为它只是一个换行，没有其他内容。对于一个没有实际内容的元素，我们会使用简写来表示这个元素，最后就会像<code>&lt;br&gt;</code>一样。<code>&lt;br&gt;</code>并不是唯一没有实际内容的元素，还有很多类似这样的元素，我们把这些元素叫做void元素（也叫作空元素）。比如说我们之前见到过的<code>&lt;img&gt;</code>元素。<h1 id="两步轻松构建HTML列表"><a href="#两步轻松构建HTML列表" class="headerlink" title="两步轻松构建HTML列表"></a>两步轻松构建HTML列表</h1></li><li>创建一个HTML列表需要两个元素，结合使用这两个元素构成了列表。第一个元素用来标记每个列表项——<code>&lt;li&gt;</code>元素(list item)。第二个元素确定你创建的是哪种类型的列表：有序列表（ordered list，用<code>&lt;ol&gt;</code>元素表示）还是无序列表（unordered list，用<code>&lt;ul&gt;</code>元素表示）。</li><li><strong>第一步：将每个列表项放在一个<code>&lt;li&gt;</code>元素中。</strong>要创建一个列表，需要把每个列表项放在单独的<code>&lt;li&gt;</code>元素中，这说明需要把内容用一个开始<code>&lt;li&gt;</code>标记和一个结束<code>&lt;/li&gt;</code>标记包围起来。与所有其它HTML元素一样，标记之间的内容由自己来确定，可以很短，也可以很长，分为多行。</li><li><strong>第二步：用<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>元素包围列表项。</strong>如果使用一个<code>&lt;ol&gt;</code>元素包围列表项，则这些列表项将作为一个有序列表显示，浏览器将会负责对每个列表项进行编号；如果使用<code>&lt;ul&gt;</code>，则列表项将显示为一个无序列表。</li><li><code>&lt;li&gt;</code>和<code>&lt;ol&gt;</code>以及<code>&lt;ul&gt;</code>元素都是块元素。</li><li>可以把一个<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>作为某个<code>&lt;li&gt;</code>的内容，这样就在列表中有了另一个列表（我们把这叫做嵌套列表）。</li><li>HTML中有有序列表和无序列表，还有另外一类列表：定义列表（用<code>&lt;dl&gt;</code>元素表示），列表中每一项都有一个定义术语<code>&lt;dt&gt;</code>和一个定义描述<code>&lt;dd&gt;</code>。<h1 id="HTML内容中特殊字符的表示方法"><a href="#HTML内容中特殊字符的表示方法" class="headerlink" title="HTML内容中特殊字符的表示方法"></a>HTML内容中特殊字符的表示方法</h1></li><li>因为浏览器要使用<code>&lt;</code>和<code>&gt;</code>来开始和结束标记，如果在HTML内容中使用这两个字符，就会有问题。不过HTML提供了一种简便的方法，可以使用一种称为字符实体(character entity)的简单缩写来指定这样一些特殊字符。它是这样工作的：对于被认为特殊的字符，或者你可能希望在Web页面中使用某个字符但在你的编辑器里无法输入(比如版权符号)，就可以查找相应的缩写在HTML中直接输入。例如，<code>&gt;</code>字符的缩写是<code>&amp;gt;</code>,<code>&lt;</code>字符的缩写是<code>&amp;lt;</code>。</li><li>加入下网在页面中输入<code>&quot;The &lt;html&gt; element rocks.&quot;</code>。通过使用字符实体，可以这样输入：<code>The &amp;lt;html&amp;gt; element rocks.</code>。还有一个特殊的字符是<code>&amp;</code>字符(与字符)。如果希望HTML内容中出现一个<code>&amp;</code>，则可以使用字符实体<code>&amp;amp;</code>，而不要直接使用字符<code>&amp;</code>。<code>&amp;</code>字符之所以特殊是因为它是所有实体的第一个字符。所以在实体名中使用<code>&amp;</code>是完全可以的，但不能单独使用<code>&amp;</code>。只要记住，输入实体时都会用到<code>&amp;</code>，而如果内容中确实需要一个<code>&amp;</code>，就要使用<code>&amp;amp;</code>。另外版权符号的表示为<code>&amp;copyright;</code>。</li><li><code>www.unicode.org</code>网站上有太多的不同字符和语言。只有当所用的计算机或设备安装了正确的字体时，浏览器才可能显示所有这些字符。</li><li>在<code>www.w3schools.com</code>上查看了字符实体，并且每个实体还有一个编号。可以在HTML中使用这个编号，比如<code>&amp;#100</code>，也可以使用实体名，它们的作用都是一样的。不过，并不是所有的实体都有名字，所以如果没有实体名，所以如果没有实体名，那么使用这个编号就是唯一选择了。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li><code>&lt;code&gt;</code>元素用来显示计算机程序代码。<code>&lt;em&gt;</code>元素来标记想用不同方式展示的文本，比如想强调一个重点。<code>&lt;time&gt;</code>元素用来告诉浏览器这个内容是一个日期或时间，或者同时包含日期和时间。<code>&lt;strong&gt;</code>元素来标记希望特别强调的文本。<code>&lt;pre&gt;</code>希望浏览器按照我们自己输入的方式原样显示文本时，使用这个元素来指定文本格式。</li><li>开始输入内容之前要规划好Web页面的结构，然后画出一个草图，然后创建一个略图，最后在写出HTML。要尽可能使用元素来告诉浏览器我们的内容的含义。一定要使用与内容含义最接近的元素。例如，如果创建一个列表，就不要使用段落元素。</li><li>块元素在内容前后分别有一个换行。</li><li>要插入自己的换行时，可以使用<code>&lt;br&gt;</code>元素，它是一个”void”元素。</li><li>void元素没有内容。并且只有一个标记组成。</li><li>“空”元素没有内容，不过它由开始和结束标记。</li><li>要对HTML中的特殊字符使用字符实体。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引用元素&lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt;和引用元素&lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt;的区别：&lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt;是内联元素，适合于小段引用时使用，而&lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt;是块元素，适合于大段引用。&lt;br&gt;一个列表由两种元素构成：列表类型和列表项。列表类型有无序列表（&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;元素表示）以及有序列表（&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;元素表示），列表项由&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;元素表示。这三个元素都是块元素。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTML和CSS(二)</title>
    <link href="http://yoursite.com/2019/01/20/HTML%E5%92%8CCSS(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/01/20/HTML和CSS(二)/</id>
    <published>2019-01-20T03:10:24.000Z</published>
    <updated>2019-01-22T10:22:17.802Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>&lt;a&gt;</code>元素创建一个超文本链接，链接到另一个Web页面。<code>&lt;a&gt;</code>元素的内容会成为Web页面中可单击的文本。href属性告诉浏览器链接的目标文件。<br><a id="more"></a><br>嘻嘻，考完试回家了，终于可以尽情放飞自我了！！！开心.jpg</p><ul><li>在（一）中我们提到HTML，它是一种标记语言（HTML中的“ML”），用来描述网页的结构。而HTML中的“HT”，也就是超文本（hypertext），它可以使我们摆脱单个页面的束缚，链接到其它页面。<h1 id="如何创建一个浏览器链接？"><a href="#如何创建一个浏览器链接？" class="headerlink" title="如何创建一个浏览器链接？"></a>如何创建一个浏览器链接？</h1></li><li>在创建HTML链接时，首先需要把链接文本放在<code>&lt;a&gt;</code>元素中。<br>for example:<code>&lt;a&gt;elixirs&lt;/a&gt;</code>，<code>&lt;a&gt;driving directions&lt;/a&gt;</code>，<code>&lt;a&gt;</code>元素用于创建指向另一个页面的链接，<code>&lt;a&gt;</code>元素的内容就是链接文本。在浏览器中，链接文本会显示有下划线，指示这是可以单击的。</li><li>有了链接文本后还得增加一些HTML告诉浏览器这个链接指向哪里，要通过href属性来指定链接的目标文件。<br>for example:<code>&lt;a href=&quot;elixir.html&quot;&gt;elixirs&lt;/a&gt;</code>，对于这个链接，浏览器会显示文本”elixirs”，单击这个文本时，用户将被带往”elixir.html”页面。<br><code>&lt;a href=&quot;directions.html&quot;&gt;driving directions&lt;/a&gt;</code>，对于这个链接，浏览器会显示”driving directions”链接，单击时，用户会进入”directions.html”页面。<h1 id="浏览器做了什么？"><a href="#浏览器做了什么？" class="headerlink" title="浏览器做了什么？"></a>浏览器做了什么？</h1></li><li>首先，浏览器会显示页面，如果遇到一个<code>&lt;a&gt;</code>元素，则会取这个元素的内容，把它显示为一个可单击的链接。</li><li>接下来，用户单击一个链接时，浏览器使用”href”属性来确定这个链接指向哪个页面。<h1 id="了解属性"><a href="#了解属性" class="headerlink" title="了解属性"></a>了解属性</h1></li><li>利用属性(Attributes)，可以指定一个元素的附加信息。<br>for example:<br>  <code>&lt;style type=&quot;text/css&quot;&gt;</code>，type属性指定我们使用哪一种样式语言，这里就是css。<br>  <code>&lt;a href=&quot;irule.html&quot;&gt;</code>，href属性告诉我们一个超链接的目标文件。<br>  <code>&lt;img src=&quot;sweetphoto.gif&quot;&gt;</code>，src属性指定一个img标记显示的图像的文件名。</li><li>有了属性，就可以用各种信息定制这个元素。属性的写法都是一样的：首先是属性名，后面是一个等于号，然后是用双引号括起来的属性值（可能Web上有一些不严谨的HTML没有加双引号，不过不建议这么做，这可能会导致遇到一些问题）。</li><li>href的含义是“超文本引用”(hypertextreference)，超文本引用是互联网或计算机上的一个资源的别称。通常这个资源就是一个Web页面，不过也可以指向PDF文档……实际上可以指向各种各样的资源。</li><li>如果把一个<code>&lt;img&gt;</code>元素放在<code>&lt;a&gt;</code>标记之间，这个图像就会像文本一样可单击，即图像也可以作为链接。同样也可以将一个段落，即把一个<code>&lt;p&gt;</code>元素放在<code>&lt;a&gt;</code>元素中来链接整个段落。但是我们大多会在<code>&lt;a&gt;</code>元素中使用文本和图像。<code>&lt;h1&gt;</code>元素也可以放在<code>&lt;a&gt;</code>元素之间。<h1 id="组织文件夹"><a href="#组织文件夹" class="headerlink" title="组织文件夹"></a>组织文件夹</h1></li><li>注意网页文件的结构，一般会将图片单独放在根目录下的一个文件夹中，这样方便所有的网页都可以使用该文件夹下的图片。当然也可以将图片文件夹放在根目录的子文件夹下面。</li><li>告诉浏览器上行的方法是使用<code>&quot;..&quot;</code>，而如果需要向上两级文件夹的话，可以使用<code>&quot;../..&quot;</code>，也就是说每一次使用<code>&quot;..&quot;</code>，就会向上到上一层父文件夹。所以要想向上两级文件夹的话，就使用两次<code>&quot;..&quot;</code>，仍然要用<code>&quot;/&quot;</code>分割每一部分。</li><li>还需要注意的是，对于网页，只能使用<code>&quot;/&quot;</code>(斜线)作为分隔符。不要使用<code>&quot;\&quot;</code>(反斜线)。不同的操作系统使用不同的文件分割符（例如，Windows使用<code>&quot;\&quot;</code>而不是<code>&quot;/&quot;</code>），但是在Web上，我们使用一个通用的分隔符，所有操作系统都要使用这个分隔符，也就是在HTML的路径中都要使用<code>&quot;/&quot;</code>。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>想从一个页面链接到另一个页面，要使用<code>&lt;a&gt;</code>元素。<code>&lt;a&gt;</code>元素的href属性指定了链接的目标文件。<code>&lt;a&gt;</code>元素的内容是链接的标签。这个标签就是在网页上看到的链接文本。默认地，这个标签会有下划线，指示这是可以单击的。文字或图像都可以都可以用作链接的标签。单击一个链接时，浏览器会加载href属性中指定的Web页面。可以链接到相同文件夹中的文件，也可以链接到其它文件夹中的文件。</li><li>相对路径是相对于链接的源Web页面指向网站中其他文件的一个链接。就像在地图上一样，终点总是相对于起点。使用<code>&quot;..&quot;</code>可以链接到源文件上一层文件夹中的一个文件。<code>&quot;..&quot;</code>表示的是“父文件夹”。要用<code>&quot;/&quot;</code>(斜线)字符分割路径中的各个部分。</li><li>指向一个图像的路径不正确时，会在Web页面上看到一个损坏的图像。为网站选择的文件名和文件夹名中不要使用空格。</li><li>最好在构建网站初期组织网站文件，这样就不用在网站升级时修改一大堆的路径了。组织网站有很多方法，具体如何组织由自己决定。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素创建一个超文本链接，链接到另一个Web页面。&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素的内容会成为Web页面中可单击的文本。href属性告诉浏览器链接的目标文件。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTML和CSS(一)</title>
    <link href="http://yoursite.com/2018/12/09/HTML%E5%92%8CCSS(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/12/09/HTML和CSS(一)/</id>
    <published>2018-12-09T07:32:50.000Z</published>
    <updated>2019-01-20T03:33:46.342Z</updated>
    
    <content type="html"><![CDATA[<p>对HTML和CSS初步了解，二者是完全不同的语言，HTML决定了网页的结构，CSS决定了网页的样式。二者共同决定了网页的表现。<br><a id="more"></a></p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li>HTML(HyperText Markup Language)即超文本标记语言，可以用该语言来编写文件建立Web页面，将这些Web页面放在Web服务器上，连接到互联网的PC和其它设备就可以用浏览器来得到此页面。根据Web页面的HTML，浏览器可以知道显示页面所需的全部信息。可以说HTML是浏览器显示页面的关键。</li><li>第一个HTML文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Starbuzz Coffee&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Starbuzz Coffee Beverages&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;House Blend, $1.49&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A smooth, mild blend of coffees from Mexico, Bolivia</span><br><span class="line">       and Guatemals.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Mocha Cafe Latte, $2.35&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;Espresso, steamed milk and chocolate syrup.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Cappuccino, $1.89&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A mixture of espresso, steamed milk and foam.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Chai Tea, $1.85&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A spicy drink made with black tea, spices, milk and </span><br><span class="line">       honey.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>要告诉浏览器页面的结构，就需要用成对的标记包围页面的内容。<br>需要注意的是 元素 = 开始标记 + 内容 + 结束标记，举个例子：<br>    <code>&lt;h1&gt;Starbuzz Coffee Beverages&lt;/h1&gt;</code><br>就是一个<code>&lt;h1&gt;</code>元素。</p><ul><li>HTML提供了一种方法来描述文件中内容的结构。浏览器在显示HTML时，它会使用它自己的内置的默认样式来表示这个结构。不过这远远不能满足我们的需求，于是就产生了CSS。<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1></li><li>CSS(Cascading Style Sheets)即层叠样式表，它提供一种方法来告诉浏览器页面中的元素该如何显示。</li><li>style元素。<code>&lt;style&gt;</code>元素放在HTML的首部里，与其它元素类似，<code>&lt;style&gt;</code>元素有一个开始标记<code>&lt;style&gt;</code>，还有一个结束标记<code>&lt;/style&gt;</code>。且该标记还有一个可选的属性（属性用来提供一个元素的附加信息），名为type，它告诉浏览器我们在使用什么类型的样式，由于我们使用的是CSS,所以可以指定”text/css”类型。</li><li>对上面的页面加一些样式，新的代码如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Starbuzz Coffee&lt;/title&gt;</span><br><span class="line">&lt;style type = &quot;text/css&quot;&gt;</span><br><span class="line">body &#123;</span><br><span class="line">background-color: #d2b48c;        &lt;!-- 设置背景色为土黄色，这是用十六进制码指定一个颜色 --&gt;</span><br><span class="line">margin-left: 20%;</span><br><span class="line">margin-right: 20%;                        &lt;!-- 设置左右外边距分别占页面的20% --&gt;</span><br><span class="line">border: 2px dotted black;             &lt;!-- 定义页面主体周围的边框是虚线，颜色为黑色 --&gt;</span><br><span class="line">padding: 10px 10px 10px 10px;    &lt;!-- 在页面主体周围创建一些内边距 --&gt;</span><br><span class="line">font-family: sans-serif;                   &lt;!-- 定义文本使用的字体 --&gt;</span><br><span class="line">&#125;    &lt;!-- &lt;body&gt;元素表示花括号之间的所有CSS都要应用于HTML --&gt; </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Starbuzz Coffee Beverages&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;House Blend, $1.49&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A smooth, mild blend of coffees from Mexico, Bolivia</span><br><span class="line">       and Guatemals.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Mocha Cafe Latte, $2.35&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;Espresso, steamed milk and chocolate syrup.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Cappuccino, $1.89&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A mixture of espresso, steamed milk and foam.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Chai Tea, $1.85&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A spicy drink made with black tea, spices, milk and </span><br><span class="line">       honey.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>不过虽然自己用的是谷歌浏览器但是也没有显示边框。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>HTML和CSS是我们用来创建网页的语言。</li><li>Web服务器存储并提供由HTML和CSS创建的网页。浏览器获取页面，并根据HTML和CSS显示网页的内容。</li><li>HTML用来建立网页的结构，CSS用来控制HTML的表现。</li><li>所有页面都有一个<code>&lt;HTML&gt;</code>元素，其中还要有一个<code>&lt;head&gt;</code>元素和一个<code>&lt;body&gt;</code>元素，网页的信息放在<code>&lt;head&gt;</code>元素里，<code>&lt;body&gt;</code>元素里的内容就是将在浏览器里看到的东西。</li><li>通过HTML，我们利用标记来标志内容提供结构。我们把匹配标记以及它们包围的内容称为元素，也就是说元素是由三部分构成的：开始标记 + 内容 + 结束标记，不过需要注意的是有些元素(比如<code>&lt;img&gt;</code>)有所例外。</li><li>开始标记可以有属性，比如说我们例子中的type。</li><li>可以在<code>&lt;style&gt;</code>元素中写CSS规则，为HTML网页增加CSS。<code>&lt;style&gt;</code>元素总要放在<code>&lt;head&gt;</code>元素里。</li><li>可用CSS在HTML中指定元素的特性。<br>快要期末考试了，还有大作业没有写qaq，而且似乎最近的状态不怎么好，不过还是要加油呀！ </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对HTML和CSS初步了解，二者是完全不同的语言，HTML决定了网页的结构，CSS决定了网页的样式。二者共同决定了网页的表现。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>LCS和LIS</title>
    <link href="http://yoursite.com/2018/08/12/LCS%E5%92%8CLIS/"/>
    <id>http://yoursite.com/2018/08/12/LCS和LIS/</id>
    <published>2018-08-12T14:06:26.000Z</published>
    <updated>2018-11-13T14:44:23.564Z</updated>
    
    <content type="html"><![CDATA[<p>求解最长公共子序列与最长上升子序列问题以及如何利用最长公共子序列的求解方法来求解最长上升子序列。<br><a id="more"></a></p><h1 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h1><ul><li>LCS即<strong>最长公共子序列</strong>（Longest Common Subsequence）。</li><li><p>对于dp数组可以采用如下的定义:</p><p>   dp[i][j] :=s<sub>1</sub>…s<sub>i</sub>和t<sub>1</sub>…t<sub>j</sub>对应的LCS的长度</p></li><li><p>由此，s<sub>1</sub>…s<sub>i+1</sub>和t<sub>1</sub>…t<sub>j+1</sub>对应的最长公共子序列应该是</p><p>   1.当s<sub>i+1</sub>=t<sub>j+1</sub>时，在s<sub>1</sub>…s<sub>i</sub>和t<sub>1</sub>…t<sub>j</sub>的最长公共子序列末尾追加上s<sub>i+1</sub>.</p><p>   2.否则应该为s<sub>1</sub>…s<sub>i</sub>和t<sub>1</sub>…t<sub>j+1</sub>的最长公共子序列和s<sub>1</sub>…s<sub>i+1</sub>和t<sub>1</sub>…t<sub>j</sub>的最长公共子序列中最长的那个。</p></li><li>根据上述描述可求得dp数组的递推关系，关系可见代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int n , m;</span><br><span class="line">char s[MAX_N], t[MAX_M];</span><br><span class="line"></span><br><span class="line">int dp[MAX_N+1][MAX_M+1];    //DP数组</span><br><span class="line"></span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i] == t[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i+1][j+1] = dp[i][j] + 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, dp[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时的时间复杂度为O(nm)。</li></ul><h1 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h1><ul><li>LIS即<strong>最长上升子序列</strong>(Longest Increasing Subsequence)。</li><li>对于这种问题的求解通常有三种做法。<h2 id="1-动态规划-时间复杂度为O-n2"><a href="#1-动态规划-时间复杂度为O-n2" class="headerlink" title="1.动态规划(时间复杂度为O(n2))"></a>1.动态规划(时间复杂度为O(n<sup>2</sup>))</h2></li><li><p>定义dp[i]:=以a<sub>i</sub>为末尾的最长上升子序列的长度</p><p>  以a<sub>i</sub>结尾的上升子序列可以是:</p><p>   1.只包含a<sub>i</sub>的子序列</p><p>   2.在满足j &lt; i并且a<sub>j</sub> &lt; a<sub>i</sub>的以a<sub>j</sub>为结尾的上升子列末尾，追加上a<sub>i</sub>后得到的子序列</p></li><li>根据上述描述可求得dp数组的递推关系，关系可见代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int n,;</span><br><span class="line">int a[MAX_N];</span><br><span class="line"></span><br><span class="line">int dp[MAX_N];    //DP数组</span><br><span class="line"></span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">int res = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">for(int j = 0; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i] = max(dp[j]+1, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-动态规划-二分查找-时间复杂度为O-nlogn"><a href="#2-动态规划-二分查找-时间复杂度为O-nlogn" class="headerlink" title="2.动态规划+二分查找(时间复杂度为O(nlogn))"></a>2.动态规划+二分查找(时间复杂度为O(nlogn))</h2><ul><li><p>可以看这么一个例子：假设存在一个序列d[1..9] = 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5。<br>下面一步一步试着找出它。<br>我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。<br>此外，我们用一个变量Len来记录现在最长算到多少了</p><p>  首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p><p>  然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，这时Len=1</p><p>  接着，d[3] = 5，d[3]&gt;B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，这时候B[1..2] = 1, 5，Len＝2</p><p>  再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2</p><p>  继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6， Len = 3 了哦。</p><p>  第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3</p><p>  第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了</p><p>  第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。</p><p>  最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。</p><p>  于是我们知道了LIS的长度为5。</p><p>  !!!!! 注意。这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。</p><p>  然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)<del>~</del>于是算法的时间复杂度就降低到了O(NlogN)～！</p></li><li>根据上面的例子我们可以体会到如果子序列的长度相同，那么最末尾的元素较小的在之后会更加有优势。</li><li><p>因此我们定义dp[i]:=长度为i+1的上升子序列中末尾元素的最小值(不存在的话就是INF)，最开始全部dp[i]的值都初始化为INF。然后由前到后逐个考虑数组的元素，对于每一个a<sub>j</sub>，如果i=0或者dp[i-1] &lt; a<sub>j</sub>的话，就用dp[i] = min(dp[i], a<sub>j</sub>)进行更新。最终找出使dp[i] &lt; INF的最大的i+1就是结果了。而这个dp数组是单调递增的，所以可以知道对于每个a<sub>j</sub>最多只需要更新一次。对于这次更新应该在什么位置，不必逐个遍历，可直接使用二分搜索。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int dp[MAX_N];</span><br><span class="line"></span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">fill(dp, dp + n, INF);</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">*lower_bound(dp, dp+n, a[i]) = a[i];  </span><br><span class="line">//lower_bound(a, a+n, k)函数从已排好序的序列a中利用二分搜索指出满足ai &gt;= k的ai的最小的指针 </span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, lower_bound(dp, dp+n, INF) - dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法的缺点是求最长上升子序列的长度比较快，但最长上升子序列实际是什么很难知道。</p><h2 id="转化为求LCS（时间复杂度O-n2-）"><a href="#转化为求LCS（时间复杂度O-n2-）" class="headerlink" title="转化为求LCS（时间复杂度O(n2)）"></a>转化为求LCS（时间复杂度O(n<sup>2</sup>)）</h2></li><li>可将<strong>所求序列</strong>与<strong>所求序列排序后得到的序列</strong>求最长公共子序列，所得的最长公共子序列即是原序列的最长上升子序列。</li><li>代码可参考LCS的求解代码。</li></ul><p>参考博客：</p><p><a href="https://www.cnblogs.com/handsomecui/p/4692350.html" target="_blank" rel="noopener">handsomecui的博客</a></p><p><a href="https://blog.csdn.net/xws117/article/details/45438917" target="_blank" rel="noopener">xws117123的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求解最长公共子序列与最长上升子序列问题以及如何利用最长公共子序列的求解方法来求解最长上升子序列。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>数独求解</title>
    <link href="http://yoursite.com/2018/08/11/%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/08/11/搜索/</id>
    <published>2018-08-11T13:03:58.000Z</published>
    <updated>2018-11-13T14:47:52.142Z</updated>
    
    <content type="html"><![CDATA[<p>数独问题的求解：深度优先搜索算法以及剪枝<br><a id="more"></a></p><ul><li>对于数独问题的求解，首先考虑从左上角的空白格子开始填数字的深度优先搜索，所填的数字应该是所在行，列和方格中都没有填过的数字，可按此种方法进行减枝。但是对于空白格子多的情况，此种方法可能会超时。</li><li>考虑处理某一行时，对于某个还没用过的数字，如果该行只有一个可行的空白格子，就只能将该数填入该格子中。对于列和方块也一样。反之，如果某个格子可填的数字只有一个，也只能将该数字填入格子。这样，我们优先处理数字或格子唯一的情况。此外，如果搜索过程中发现没有可选的数字或格子这样矛盾的情况，则提前停止搜索。</li><li>但是当没有唯一确定的数字和格子时，此时的搜索又会回到原来从左上的空白格子开始填数字的方法。<strong>当人们求解数独问题时，是不会特地特地这样做的，通常会选择先处理选择少的格子</strong>。</li><li>例如，假设有一个只有五个候选数字的格子，即使其中一个出现了矛盾，依然还有四个候选数字需要尝试。也就是说，比起从左上角开始填数字，<strong>优先选择候选数字少的格子填数字要更加高效</strong>。<h1 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h1></li><li>题面：Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task. </li><li>输入：The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.</li><li>输出：For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them.</li><li>样例输入：<br>1<br>103000509<br>002109400<br>000704000<br>300502006<br>060000050<br>700803004<br>000401000<br>009205800<br>804000107</li><li>样例输出：<br>143628579<br>572139468<br>986754231<br>391542786<br>468917352<br>725863914<br>237481695<br>619275843<br>854396127</li><li>程序代码如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n; </span><br><span class="line">int tag[9][9][9];   //tag[i][j][k]表示(i,j)位置是否可填入数字i+1 </span><br><span class="line">int count[9][9];    //count[i][j]存储(i, j)位置可填入数字的个数 </span><br><span class="line">int s[9][9];         //存储数独矩阵       </span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[i][j] = 9;</span><br><span class="line">for(int k = 0; k &lt; 9; k++)</span><br><span class="line">&#123;</span><br><span class="line">tag[i][j][k] = 0;    //0表示可以放 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input()</span><br><span class="line">&#123;</span><br><span class="line">char str[10];</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;, str);</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">s[i][j] = str[j] -&apos;0&apos;;</span><br><span class="line">if(s[i][j] != 0)</span><br><span class="line">&#123;</span><br><span class="line">//我们最终只关注输入为0的位置的count值，故对于输入的数，其位置所在的count值是不用管的 </span><br><span class="line">for(int a = 0; a &lt; 9; a++)</span><br><span class="line">&#123;</span><br><span class="line">//处理行和列 </span><br><span class="line">if(tag[i][a][s[i][j] -1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[i][a][s[i][j] -1] = 1;   //1表示不能放 </span><br><span class="line">count[i][a]--;</span><br><span class="line">&#125;</span><br><span class="line">if(tag[a][j][s[i][j] - 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[a][j][s[i][j] - 1] = 1;</span><br><span class="line">count[a][j]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//处理其所在的3*3方块 </span><br><span class="line">int area = i / 3 * 3 + j / 3;    //计算方格块的编号 </span><br><span class="line">for(int b = area/3*3; b &lt; area/3*3+3; b++)</span><br><span class="line">&#123;</span><br><span class="line">for(int c = area%3*3; c &lt; area%3*3+3; c++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[b][c][s[i][j] - 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[b][c][s[i][j] - 1] = 1;</span><br><span class="line">count[b][c]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool search(int num)</span><br><span class="line">&#123;</span><br><span class="line">int x, y;</span><br><span class="line">int min = 10;</span><br><span class="line">//printf(&quot;此时num = %d\n&quot;, num);</span><br><span class="line"></span><br><span class="line">//找s[i][j] == 0并且count[i][j]最小的位置 </span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j] == 0 &amp;&amp; min &gt; count[i][j])</span><br><span class="line">&#123;</span><br><span class="line">min = count[i][j];</span><br><span class="line">x = i;</span><br><span class="line">y = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(min == 10)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[x][y][i-1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">s[x][y] = i;</span><br><span class="line">for(int a = 0; a &lt; 9; a++)</span><br><span class="line">&#123;</span><br><span class="line">//行和列 </span><br><span class="line">if(tag[x][a][i-1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[x][a][i-1] = num;</span><br><span class="line">count[x][a]--;</span><br><span class="line">&#125;</span><br><span class="line">if(tag[a][y][i-1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[a][y][i-1] = num;</span><br><span class="line">count[a][y]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//处理其所在的3*3方块 </span><br><span class="line">int area = x / 3 * 3 + y / 3;    //计算方格快的编号 </span><br><span class="line">for(int b = area/3*3; b &lt; area/3*3+3; b++)</span><br><span class="line">&#123;</span><br><span class="line">for(int c = area%3*3; c &lt; area%3*3+3; c++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[b][c][i - 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[b][c][i - 1] = num;</span><br><span class="line">count[b][c]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">             </span><br><span class="line">int result = search(num + 1);</span><br><span class="line">if(result == 1)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s[x][y] = 0;</span><br><span class="line">for(int a = 0; a &lt; 9; a++)</span><br><span class="line">&#123;</span><br><span class="line">//行和列 </span><br><span class="line">if(tag[x][a][i-1] == num)</span><br><span class="line">&#123;</span><br><span class="line">tag[x][a][i-1] = 0;</span><br><span class="line">count[x][a]++;</span><br><span class="line">&#125;</span><br><span class="line">if(tag[a][y][i-1] == num)</span><br><span class="line">&#123;</span><br><span class="line">tag[a][y][i-1] = 0;</span><br><span class="line">count[a][y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">area = x / 3 * 3 + y / 3;    //计算方格快的编号 </span><br><span class="line">for(int b = area/3*3; b &lt; area/3*3+3; b++)</span><br><span class="line">&#123;</span><br><span class="line">for(int c = area%3*3; c &lt; area%3*3+3; c++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[b][c][i - 1] == num)</span><br><span class="line">&#123;</span><br><span class="line">tag[b][c][i - 1] = 0;</span><br><span class="line">count[b][c]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;, s[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">input();</span><br><span class="line">search(2);</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数独问题的求解：深度优先搜索算法以及剪枝&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="搜索" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>c++之string类简述</title>
    <link href="http://yoursite.com/2018/07/30/c++%E4%B9%8Bstring%E7%B1%BB%E7%AE%80%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/07/30/c++之string类简述/</id>
    <published>2018-07-30T13:32:20.000Z</published>
    <updated>2018-11-13T14:39:12.771Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学了C++之后，感觉其中字符串处理涉及到了很多的方法，故将其整理下来，并将其中某些与C语言处理字符串的方法进行对比。<br><a id="more"></a><br>可能是由于受c语言的影响，现在好多时候写题还是用char数组字符串比较多，不过感觉用起来似乎比较麻烦，就决定整理一下<strong>c++中的string类的用法</strong>。</p><h1 id="声明一个C-字符串"><a href="#声明一个C-字符串" class="headerlink" title="声明一个C++字符串"></a>声明一个C++字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br></pre></td></tr></table></figure><ul><li>这样就声明了一个字符串变量<strong>str</strong>,由于其构造函数没有传入参数，故此时将str初始化为一个<strong>空字符串</strong>。<h2 id="string类中的构造函数和析构函数如下："><a href="#string类中的构造函数和析构函数如下：" class="headerlink" title="string类中的构造函数和析构函数如下："></a>string类中的构造函数和析构函数如下：</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s; //生成一个空字符串s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(str); //拷贝构造函数，将str复制到s中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(str, stridx); //将字符串str内**始于位置stridx**的部分当作字符串的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(str, stridx, strlen); //将字符串str内**始于stridx且长度至多为strlen**的部分作为字符串的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(cstr); //将c字符串作为s的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(chars, chars_len); //将c字符串前的至多chars_len个字符串作为字符串s的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(num, c); //生成一个字符串，包含num个c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.~string(); //销毁所有字符，释放内存</span><br></pre></td></tr></table></figure><h1 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h1><ul><li>=，aasign()   //赋值 </li><li>swap()    //交换两个字符串的内容，既可以用作成员函数也可以用作普通函数</li><li>+=,append(),push_back()  //在尾部添加字符，前两个也可添加字符串，后一个只能添加字符</li><li>insert()   //插入字符，有两个参数</li><li>erase()    //删除字符</li><li>clear()    //删除全部字符</li><li>replace()  //替换字符，可将字符串的某段替换为其他字符串</li><li><ul><li>//字符串拼接</li></ul></li><li>==, !=, &lt;, &lt;=, &gt;, &gt;=, compare()     //字符串比较</li><li>size(), length()   //返回字符串中的字符数量，<strong>注意如果求字符数组的长度的话可以用strlen()函数</strong></li><li>max_size()     //返回字符的可能最大个数</li><li>empty()     //判断字符串是否为空</li><li>capacity()   //返回重新分配之前的字符容量</li><li>reverse()   //字符串转置，<strong>注意如果是用字符数组表示字符串的话可用strrev()函数来进行字符串转置</strong></li><li>[],at()    //存取单一字符串</li><li>getline()   //从输入流读入一行</li><li>copy(p,n,size_type _Off = 0)   //从string类型对象中至多复制n个字符到字符指针p指向的空间中。默认从首字符开始，但是也可以指定，开始的位置（记住从0开始）。返回真正从对象中复制的字符。<strong>用户要确保p指向的空间足够保存n个字符</strong>。</li><li>c_str()   //取得c分格的const char *字符串</li><li>data()    //取得字符串内容的地址</li><li>substr()   //返回某个子字符串</li><li>begin()    //得到指向字符串开头的iterator</li><li>end()      //得到指向字符串结尾的iterator</li><li>rbegin()    //得到指向反向字符串开头的iterator</li><li>rend()      //得到指向反向字符串结尾的iterator</li><li>find_first_of()     //查找包含子串中的任何字符，返回第一个位置</li><li>find_first_not_of()     //查找不包含子串中的任何字符，返回第一个位置</li><li>find_last_of()    //查找包含子串中的任何字符，返回最后一个位置</li><li>find_last_not_of()    //查找不包含子串中的任何字符，返回最后一个位置</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学了C++之后，感觉其中字符串处理涉及到了很多的方法，故将其整理下来，并将其中某些与C语言处理字符串的方法进行对比。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>输入输出流对象</title>
    <link href="http://yoursite.com/2018/04/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/04/22/输入输出流对象/</id>
    <published>2018-04-22T05:07:50.000Z</published>
    <updated>2018-11-13T14:53:13.214Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的输入输出流,以及一些有限定条件的输入输出方法。<br><a id="more"></a><br>哈哈，今天终于开始更新博客了(<em>^▽^</em>)一时不知道写什么好，就写一下最近学到的东西吧！</p><h1 id="输出流与输入流"><a href="#输出流与输入流" class="headerlink" title="输出流与输入流"></a>输出流与输入流</h1><ul><li><strong>cout</strong>是一个输出流对象，它是“console out”(控制台输出)的缩写,又称为插入运算符，是输出数据的，是属于basic_ostream类中的对象。而ostream类在iostream头文件中定义。</li><li><strong>cin</strong>是一个输入流对象，又称为提取操作符，用来获取用户外部输入的数据，当用户进行键盘输入时，对应的字符将输入到操作系统的键盘缓冲区，当用户点击”Enter”键时，操作系统把键盘缓冲区的内容传输到cin流的内部缓冲区，<strong>“&gt;&gt;”</strong>操作符随后从这个缓冲区提取需要的信息，它是属于istream类中的对象。</li><li>在C++中左移，右移操作符进行了重载。</li><li><p>下面列举一些<strong>cin</strong>和<strong>cout</strong>的用法:</p><h2 id="cin-ignore-amp-cin-getline"><a href="#cin-ignore-amp-cin-getline" class="headerlink" title="cin.ignore() &amp; cin.getline()"></a>cin.ignore() &amp; cin.getline()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[20];</span><br><span class="line">cin.ignore(7);</span><br><span class="line">cin.getline( buf, 10 );</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>使用cin.ignore(7)在输入时会忽略输入的前7个字符。</p></li><li>使用cin.getline（buf, 10）在输入时只会得到前10个字符，注意这10个字符中还要包括’/0’。</li></ul><h2 id="cin-peek-amp-cin-get"><a href="#cin-peek-amp-cin-get" class="headerlink" title="cin.peek() &amp; cin.get()"></a>cin.peek() &amp; cin.get()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char p;</span><br><span class="line">cout &lt;&lt; &quot;请输入一段文本: \n&quot;;</span><br><span class="line">while( cin.peek() != &apos;\n&apos; )</span><br><span class="line">&#123;</span><br><span class="line">      p = cin.get();</span><br><span class="line">      cout &lt;&lt; p;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>cin.peek()函数的返回值是一个<strong>char</strong>型的字符，其返回值是指针指向的当前字符。</li><li>cin.get()函数用来从指定的输入流中提取一个字符(包括空白字符)，函数的返回值就是读入的字符。</li></ul><h2 id="cin-gcount-amp-cin-read"><a href="#cin-gcount-amp-cin-read" class="headerlink" title="cin.gcount() &amp; cin.read()"></a>cin.gcount() &amp; cin.read()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int SIZE = 50;</span><br><span class="line">char buf[SIZE];</span><br><span class="line">cout &lt;&lt; &quot;请输入一段文本: &quot;;</span><br><span class="line">cin.read( buf, 20 );</span><br><span class="line">cout &lt;&lt; &quot;字符串收集到的字符数为: &quot; &lt;&lt; cin.gcount() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;输入的文本信息是: &quot;;</span><br><span class="line">cout.write( buf, 20 );</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>cin.gcount()函数返回一个非格式化的提取方法读取的字符数，这以为着字符是由<strong>cin.get(),cin.getline(),cin.ignore()或cin.read()</strong>函数读取的，不是又提取操作符”&gt;&gt;”读取的。</li><li>cin.read(buf,20)是读取长度为20的字符串给buf字符数组中，该字符串中包括了’\0’。</li></ul><h2 id="cout-precision-amp-cout-width"><a href="#cout-precision-amp-cout-width" class="headerlink" title="cout.precision() &amp; cout.width()"></a>cout.precision() &amp; cout.width()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double result = sqrt(3.0);</span><br><span class="line">cout &lt;&lt; &quot;对 3 开方保留小数点后0 ~ 9 位，结果如下: \n&quot; &lt;&lt;endl;</span><br><span class="line">for( int i=0; i &lt;= 9; i++ )</span><br><span class="line">&#123;</span><br><span class="line">     cout.precision(i);</span><br><span class="line">     cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;当前的输出精度为: &quot; &lt;&lt; cout.precision() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>cout.precision(i)函数设置当前输出精度为i,输出小数点后<strong>i-1</strong>位，第i位四舍五入。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int width = 4;</span><br><span class="line">char str[20];</span><br><span class="line">cout &lt;&lt; &quot;请输入一段文本: \n&quot;;</span><br><span class="line">cin.width(5);</span><br><span class="line">while( cin &gt;&gt; str )</span><br><span class="line">&#123;</span><br><span class="line">     cout.width(width++);</span><br><span class="line">     cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">     cin.width(5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cin.width(n)读取长度为n的字符，注意最后一个字符为’\0’。</li><li>cout.width(n)设置输出宽度为n，不足的用空格补齐。<h1 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h1></li><li><strong>cout</strong>这个输出流对象是在名字空间<strong>std</strong>中来定义的。</li><li><p>在使用时可以直接用指令<strong>using namespace std</strong>，然后再使用<strong>cout</strong>，或者直接使用<strong>std::cout</strong>。</p><p><code>std::cout&lt;&lt;&quot;This is a test&quot;&lt;&lt;endl</code></p></li></ul><p>第一次写就先写到这了，希望以后自己能坚持下去!ヾ(◍°∇°◍)ﾉﾞ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++中的输入输出流,以及一些有限定条件的输入输出方法。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
