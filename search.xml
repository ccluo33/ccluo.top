<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>机器学习简介</title>
      <link href="/2019/04/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/04/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li>机器学习有很多分类，主要可以分为监督学习（supervised learning）和无监督学习（unsupervised learning）。</li><li>监督学习是指教计算机怎么学习，无监督学习是指让计算机自己学习。</li><li>监督学习可以分为分类问题(classification problems)和回归问题(regression problems)，分类问题对应于离散的情况，而回归问题对应于连续的情况。对于只有少量离散值的问题，应该将它作为分类问题。</li><li>在无监督学习中，所给的数据没有标签或者标签都相同，常使用聚类算法(clustering algorithm)，将数据集划分为不同的簇；另一个使用无监督学习方法的问题时鸡尾酒会的音频分离问题。<h1 id="线性回归-linear-regression"><a href="#线性回归-linear-regression" class="headerlink" title="线性回归(linear regression)"></a>线性回归(linear regression)</h1></li><li>线性回归中假设函数(hypothesis function)$h_{\theta}(x)$用来预测y是x的线性函数。<h2 id="Linear-regression-with-one-variable"><a href="#Linear-regression-with-one-variable" class="headerlink" title="Linear regression with one variable"></a>Linear regression with one variable</h2></li><li>Cost function（代价函数）有助于我们弄清楚如何把最有可能的直线与我们的数据相拟合。</li><li>在线性回归中假设函数的形式为<script type="math/tex">h_{\theta}(x) = \theta _{0}+\theta _{1}x</script>，其中<script type="math/tex">\theta _{i}</script>称为模型参数。</li><li>如何选择<script type="math/tex">\theta _{0}</script>和<script type="math/tex">\theta _{1}</script>这两个参数？选取的原则是对于我们给定的训练集中的数据，使<script type="math/tex">h_{\theta}(x)</script>尽可能靠近y。也就是求解最小化问题<script type="math/tex">\underset{\theta _{0},\theta _{1}}minimize\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta }(x^{i})-y^{i})^{2}</script>(m是训练集中样本的数量)。</li><li>在该问题中的代价函数为<script type="math/tex">J(\theta _{0},\theta _{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta }(x^{i})-y^{i})^{2}</script>，代价函数的参数是模型参数，我们的目标是最小化代价函数，即求<script type="math/tex">\underset{\theta _{0},\theta_{1}}{mininmize}J(\theta_{0}, \theta_{1})</script>。</li><li>上述代价函数也被称为平方误差函数，有时也被称为误差平方代价函数。平方误差代价函数是解决回归问题最常用的手段。<h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3></li><li>可以使用梯度下降法(gradient descent algorithm)将代价函数最小化。</li><li>梯度下降法的步骤为:<br><br>&emsp;&emsp;repeat until convergence{<br><br>&emsp;&emsp;&emsp;<script type="math/tex">\theta _{j} := \theta _{j}-\alpha \frac{\partial }{\partial\theta _{j}}J(\theta _{0},\theta _{1})</script>&emsp;(for j = 0 and j = 1)<br><br>&emsp;&emsp;}</li><li>注意上述步骤在实现时要做到同步更新。<br><br><img src="机器学习简介/machinelearning1.jpg" alt="同步更新"></li><li>其中<script type="math/tex">\alpha</script>是学习率(learning rate)，它用来控制梯度下降时，我们迈出多大的步子。如果<script type="math/tex">\alpha</script>太小，我们就需要很多步才能达到全局最优解或者局部最优解。如果<script type="math/tex">\alpha</script>值很大，梯度下降可能越过最低点，甚至可能无法收敛(converge)，甚至发散(diverge)。</li><li>递归下降法可以收敛到一个局部最小值，甚至是在学习率固定的情况下。因为当我们接近一个局部最小值时（因为导数在逐渐减小），梯度下降法将会自动地减小步子。因此， 我们不需要去减小学习率。</li><li>对于线性回归问题，梯度下降算法的步骤为：<br><br>&emsp;&emsp;repeat until convergence{<br><br>&emsp;&emsp;&emsp;<script type="math/tex">\theta _{0} := \theta _{0}-\alpha \frac{1}{m}\sum_{i=1}^{m}(h_{\theta }(x_{i})-y^{(i)})</script><br><br>&emsp;&emsp;&emsp;<script type="math/tex">\theta _{1} := \theta _{1}-\alpha \frac{1}{m}\sum_{i=1}^{m}(h_{\theta }(x_{i})-y^{(i)})</script><br><br>&emsp;&emsp;}</li><li>注意update <script type="math/tex">\theta _{0}</script> and <script type="math/tex">\theta _{1}</script> simultaneously</li><li>可能会有这么一个问题：使用梯度下降法不会陷入局部最优解吗？因为线性回归的代价函数是一个凸函数(convex function)，该函数没有局部最优解，只有一个全局最优解，故不会出现这种情况。</li><li>上面的梯度下降算法也常被称作”Batch” Gradient Descent, “Batch” means each step of gradient descent uses all the training examples.</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简介 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>stringstream常见用法</title>
      <link href="/2019/03/15/stringstream%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
      <url>/2019/03/15/stringstream%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>stringstream常用来进行输入输出格式转换，有时候也用来进行字符串合并。<br><br>stringstream两种清空的方法，以及两种方法的使用场景的区别。<br><a id="more"></a><br>这几天的我好丧啊，不知道自己该干什么，没有一个目标，什么事情都想干，可是自己又超级懒，连后天的考试都没怎么准备，哎o(╥﹏╥)o</p><h1 id="lt-sstream-gt-头文件介绍"><a href="#lt-sstream-gt-头文件介绍" class="headerlink" title="&lt;sstream&gt;头文件介绍"></a><code>&lt;sstream&gt;</code>头文件介绍</h1><p><code>&lt;sstream&gt;</code>定义了三个类：istringstream,ostringstream和stringstream，分别用来进行流的输入，输出和输入输出操作。这里主要介绍一下stringstream。<br><br><code>&lt;sstream&gt;</code>主要用来进行数据类型转换，由于<code>&lt;sstream&gt;</code>使用string对象来代替字符数组(sprintf方式)，就避免了缓冲区溢出的危险。而且，因为传入参数和<br>目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题。简单来说，相比C语言库的数据类型转换而言，<code>&lt;sstream&gt;</code>更加安全，自动和直接。<br></p><h2 id="stringstream用于数据类型转换"><a href="#stringstream用于数据类型转换" class="headerlink" title="stringstream用于数据类型转换"></a>stringstream用于数据类型转换</h2><p>比如说将一个int类型转换为字符串型，<br>这可以使用sprintf来实现，不过必须保证目标缓冲区有足够大的空间以容纳转换完的字符串：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int nValue = 1000;</span><br><span class="line">char s[10];</span><br><span class="line">sprintf(s, &quot;%d&quot;, nValue);</span><br><span class="line">printf(&quot;%s\n&quot;, s);</span><br></pre></td></tr></table></figure></p><p>这样看起来也还行，只需要将字符数组开得足够大，放得下转换完的字符串就ok。<br><br>不过如果对上面的代码做一个微小的改变就会使得程序崩溃：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int nValue = 1000;</span><br><span class="line">char s[10];</span><br><span class="line">sprintf(s, &quot;%f&quot;, nValue);   //错误的格式化符 </span><br><span class="line">printf(&quot;%s\n&quot;, s);</span><br></pre></td></tr></table></figure></p><p>在这种情况下，错误地使用了%f格式化符来替代了%d。因此，s在调用完sprintf()后包含了一个不确定的字符串。如果要是能推导出正确的类型，岂不是要方便许多，所以我们选择使用stringstream：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stringstream ss;</span><br><span class="line">string strResult;</span><br><span class="line">int nValue = 1000;</span><br><span class="line"></span><br><span class="line">//将int类型的值放入输入流中</span><br><span class="line">ss &lt;&lt; nValue;    </span><br><span class="line">//从ss中抽取前面插入的int类型的值，赋值给string类型 </span><br><span class="line">ss &gt;&gt; strResult;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;[cout]strResult is: &quot; &lt;&lt; strResult &lt;&lt; endl;</span><br><span class="line">printf(&quot;[printf]strResult is: %s\n&quot;, strResult.c_str());</span><br></pre></td></tr></table></figure></p><p>此时不必担心缓冲区溢出，因为stringstream对象会根据需要自动分配存储空间。</p><h2 id="stringstream用于多个字符串拼接"><a href="#stringstream用于多个字符串拼接" class="headerlink" title="stringstream用于多个字符串拼接"></a>stringstream用于多个字符串拼接</h2><p>举个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stringstream ss;</span><br><span class="line"></span><br><span class="line">//将多个字符串放入ss中</span><br><span class="line">ss &lt;&lt; &quot;first&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;string,&quot;;</span><br><span class="line">ss &lt;&lt; &quot; second string&quot;;</span><br><span class="line">cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; ss.str() &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">//清空ss</span><br><span class="line">ss.str(&quot;&quot;);</span><br><span class="line">ss &lt;&lt; &quot;third string&quot;;</span><br><span class="line">cout &lt;&lt; &quot;After clear, strResult is: &quot; &lt;&lt; ss.str() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><p>此程序的输出结果为：<br><br><img src="images/stringstream.jpg" alt=""><br>从上述代码可以知道：</p><p><ul>    <li>可以使用str()方法，将stringstream类型转换为string类型；</li>    <li>可以将多个字符串放入stringstream中，实现字符串拼接的目的；</li>    <li>如果想清空stringstream，必须使用s.str("")方式。</li></ul></p><h2 id="stringstream的清空"><a href="#stringstream的清空" class="headerlink" title="stringstream的清空"></a>stringstream的清空</h2><p>清空stringstream有两种方法，前面已经见到了一种：str(“”)方法，还有一种方法是clear()。这两种方法的使用场景是不同的。<br><br>上面的代码已经展示了str(“”)的使用场景，下面就clear()方法的使用场景来举个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stringstream ss;</span><br><span class="line">int first, second;</span><br><span class="line"></span><br><span class="line">//插入字符串</span><br><span class="line">ss &lt;&lt; &quot;456&quot;;</span><br><span class="line">//转换为int类型</span><br><span class="line">ss &gt;&gt; first;</span><br><span class="line">cout &lt;&lt; first &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">//在进行多次类型转换前，必须先运行clear() </span><br><span class="line">ss.clear();</span><br><span class="line"></span><br><span class="line">//插入bool值</span><br><span class="line">ss &lt;&lt; true;</span><br><span class="line">//转换为int类型</span><br><span class="line">ss &gt;&gt; second;</span><br><span class="line">cout &lt;&lt; second &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><p>运行后输出的结果为:<br><img src="images/stringstream1.jpg" alt=""><br>在这个例子涉及的场景下（多次数据类型转换），必须使用clear()方法清空stringstream，不使用clear()方法或者使用str(“”)方法，都不能得到数据类型转换的正确结果。不使用clear()方法得到的运行结果为：<br><img src="images/stringstream2.jpg" alt=""><br>而使用str(“”)得到的运行结果为：<br><img src="images/stringstream3.jpg" alt=""></p><p>参考博客：</p><p><a href="https://blog.csdn.net/liitdar/article/details/82598039" target="_blank" rel="noopener">liitdar的博客</a></p><p><a href="http://developer.zhiding.cn/2003/0304/83250.shtml" target="_blank" rel="noopener">至顶网</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(十)</title>
      <link href="/2019/03/04/HTML%E5%92%8CCSS(%E5%8D%81)/"/>
      <url>/2019/03/04/HTML%E5%92%8CCSS(%E5%8D%81)/</url>
      
        <content type="html"><![CDATA[<p><code>&lt;div&gt;</code>元素用于对块元素划分逻辑区，<code>&lt;span&gt;</code>元素用于对内联元素划分逻辑区<br><br>元素的一般默认宽度和高度都设置的是auto，所以随着浏览器宽度，高度改变，元素的宽度和高度会随之改变。可以使用width属性来设置元素的宽度，高度一般还是用默认属性<br><br>用text-align属性来设置块元素的对齐方式，其中内联内容会按设置的方式对齐，而该块元素中的块元素会继承该属性，再将自己对齐<br><br>使用子孙选择器来选择某元素的子孙元素<br><br>设置行高的line-height属性的属性值可以直接为一个数，表示行高是该元素中每个元素的字体大小的多少倍（如果该元素中有<code>&lt;h1&gt;</code>元素和<code>&lt;p&gt;</code>元素，则<code>&lt;h1&gt;</code>和<code>&lt;p&gt;</code>的行高不同）<br><br>设置内边距，外边距，边框，背景，字体都可以使用快捷方式<br><br>链接元素的不同状态可以用伪类来设置其表现形式<br><br>使用层叠可以确定哪个元素具体使用哪种样式<br><a id="more"></a><br>想去报名CSP和CCF又感觉没有多长时间准备，哎，不知道自己早干嘛去了。</p><h1 id="lt-div-gt-和-lt-span-gt"><a href="#lt-div-gt-和-lt-span-gt" class="headerlink" title="&lt;div&gt;和&lt;span&gt;"></a><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code></h1><p>利用<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>可以构建重要的支撑架构。<br></p><h2 id="lt-div-gt"><a href="#lt-div-gt" class="headerlink" title="&lt;div&gt;"></a><code>&lt;div&gt;</code></h2><p><code>&lt;div&gt;</code>允许你将页面划分为逻辑区或逻辑分组。<br><br>将元素嵌入在<code>&lt;div&gt;</code>中，就是在指示所有这些元素属于同一个组。并且可以使用一个id属性为<code>&lt;div&gt;</code>提供一个唯一的标签。<br><br>就像所有子元素一样，<code>&lt;div&gt;</code>中的元素也会从<code>&lt;div&gt;</code>继承一些属性（如font-size，color等）。<br><br>在有必要的情况下，也可以使用嵌套<code>&lt;div&gt;</code>。<br><br>实际上，我们通常把<code>&lt;div&gt;</code>描述为“容器”。它们不仅相当于逻辑容器，可以用来将一堆相关的元素放在一起，另外对<code>&lt;div&gt;</code>指定样式和定位时，你会看到它们还相当于图形容器。<br><br><code>&lt;div&gt;</code>只是一个块元素，可以对它应用你希望的任何样式。并且像所有其他元素一样，<code>&lt;div&gt;</code>也是一个盒子。<br></p><h2 id="lt-span-gt"><a href="#lt-span-gt" class="headerlink" title="&lt;span&gt;"></a><code>&lt;span&gt;</code></h2><p>类似于<code>&lt;div&gt;</code>的元素，只不过这个元素是针对内联元素的。<br><br>可以利用<code>&lt;span&gt;</code>创建内联字符和元素的逻辑分组。<br><br><code>&lt;div&gt;</code>允许你为块级内容创建逻辑划分，<code>&lt;span&gt;</code>元素则采用类似的方法建立内联元素的逻辑分组。<br><br>可以设置内联元素（如<code>&lt;span&gt;</code>,<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>）的宽度，不过在对这些元素定位之前（这个内容将在下一章学习），你可能注意不到宽度改变的效果。另外还可以对这些元素增加外边距，内边距以及边框。内联元素上的外边距和内边距与块元素稍有不同，如果一个内联元素四周都增加外边距，只能看到左边和右边都会增加空间。你可以对内联元素的上边和下边增加内边距，不过这个内边距不会影响包围它的其它内联元素的间距，所以内边距会与其他内联元素重叠。<br><br>图像和其他内联元素可能稍有些不同。图像的宽度，内边距和外边距属性都表现得更像是块元素的相应属性。</p><h1 id="设置元素宽度"><a href="#设置元素宽度" class="headerlink" title="设置元素宽度"></a>设置元素宽度</h1><p>width属性允许你指定元素内容区的宽度。<br><br>width属性只指定内容区的宽度。要确定整个盒子的宽度，需要将内容区的宽度加上左和右内边距，左和右边框以及左和右外边距的宽度。<br><br>一个块元素的默认宽度是auto，这说明它会延伸占满整个可用的空间。也就是说，不论将窗口调整到多宽或多窄，未指定宽度的块元素会自行调整大小。<br><br>可以使用像素指定一个元素的具体大小，此时窗口将不能调整到比该宽度小（可能有例外），不论窗口调整到多宽，该元素的内容区宽度不会发生改变。也可以使用百分数为一个元素指定具体大小，那么宽度会计算为元素所在容器宽度的一个百分比（容器可以是<code>&lt;body&gt;</code>,<code>&lt;div&gt;</code>等）。<br><br>可能会产生这么一个疑问，能否设置一个元素的高度？一般来讲，一个元素的高度是默认的。也就是auto(自动)，浏览器会在垂直方向上延伸内容区，使所有内容都可见。可以显示地设置一个高度，不过这会有风险，如果你指定的高度不够大，不足以放下内容，内容底部有可能“溢出”到其它元素中。一般地，不用指定元素的高度，就让它们默认为auto。</p><h1 id="设置对齐方式"><a href="#设置对齐方式" class="headerlink" title="设置对齐方式"></a>设置对齐方式</h1><p>可以使用块元素的text-align来对齐其中包含的文本。<br><br>text-align会对块元素的所有内联内容对齐。要记住，尽管这个属性的名字是text-align，实际上它适用于对任何类型的内联元素对齐。要记住一点，text-align属性只能在块元素上设置，如果直接在内联元素（如<code>&lt;img&gt;</code>）上使用，则不起作用。<br><br>由上一条知道，ext-align会对块元素的所有内联内容对齐。可是经过实践我们可以发现，该块元素中不光内联元素对齐了，块元素也对齐了，这就很奇怪。这是因为，这些块元素继承了其父元素设置的text-align属性，然后是它们自己将内容居中。<br><br>这可以为你提供很多种使用<code>&lt;div&gt;</code>的方法，因为你可以用<code>&lt;div&gt;</code>包围一些内容，然后对<code>&lt;div&gt;</code>应用样式，而不是对单个元素分别应用样式。当然要记住，默认地，并不是所有属性都能继承，所以这一点并不适用于所有属性。</p><h1 id="子孙选择器"><a href="#子孙选择器" class="headerlink" title="子孙选择器"></a>子孙选择器</h1><p>我们有时候想要有一种方法告诉CSS：我们只想选择某些元素的子孙元素。子孙选择器的写法为：<code>div h2 { color: black; }</code>，第一个是父元素，父元素和子孙元素名之间有一个空格，第二个元素是它的子孙元素。其余部分的写法与以往一样。这个规则指出要选择作为一个<code>&lt;div&gt;</code>子孙的所有<code>&lt;h2&gt;</code>。<br><br>不过，如果要唯一地对某个<code>&lt;div&gt;</code>元素指定样式，就要对该<code>&lt;div&gt;</code>元素使用id属性，比如说指定该<code>&lt;div&gt;</code>元素的id属性值为elixirs，下面可以使用这个id更特定地指定我们想要的子孙元素：<code>#elixirs h2 { color: black; }</code>，现在父元素为id是elixirs的元素。<br><br>选择器”#elixirs h2”表示选择的<code>&lt;h2&gt;</code>元素可以是elixirs的所有子孙，所以这个<code>&lt;h2&gt;</code>可以是<code>&lt;div&gt;</code>的直接孩子，也可以嵌套在一个<code>&lt;blockquote&gt;</code>或另一个嵌套的<code>&lt;div&gt;</code>中（这就成为一个孙子），依次类推，所以子孙选择器会选择一个元素中嵌套的所有<code>&lt;h2&gt;</code>，而不论它嵌套的有多深。<br><br>那么有没有一种办法选择直接的孩子？有的！可以使用<code>#elixirs&gt;h2</code>，这样一来，只有当<code>&lt;h2&gt;</code>是一个id为”elixirs”的元素的直接孩子时，才会选择这个<code>&lt;h2&gt;</code>。<br><br>如果需要选择一个<code>&lt;h2&gt;</code>，要求它是一个<code>&lt;blockquote&gt;</code>的孩子，而且<code>&lt;blockquote&gt;</code>必须在elixirs中，应该怎么写选择器？此时应该需要使用更多子孙选择器，写为：<code>#elixirs blockquote h2 { color: blue; }</code>。</p><h1 id="修改行高"><a href="#修改行高" class="headerlink" title="修改行高"></a>修改行高</h1><p>对于一个<code>&lt;div&gt;</code>元素，如果想修改其中内容的行高，只需要设置line-height属性就可以了。但是因为行高会继承，所以此时<code>&lt;div&gt;</code>中可能元素的字体大小不一样，但行高却一样。导致有些内容两行都快挤到一起了。<br><br>我们真正希望的是，<code>&lt;div&gt;</code>中所有元素的行高不要基于<code>&lt;div&gt;</code>的字体大小，而要基于各个元素本身的字体大小。比如说这个<code>&lt;div&gt;</code>元素中有<code>&lt;h2&gt;</code>元素，也有<code>&lt;p&gt;</code>元素，我们希望<code>&lt;h2&gt;</code>标题的行高为其字体大小的1倍（即”small”的120%），<code>&lt;p&gt;</code>的行高应该是其字体大小的1倍（即”small”）。<br><br>line-height属性有一点特殊，因为你可以对它直接使用一个数，而不是一个相对度量（比如em或%）。如果使用数1，就表示该<code>&lt;div&gt;</code>中的各个元素行高是其字体大小的1倍，而不是该<code>&lt;div&gt;</code>元素字体大小的1倍。</p><h1 id="属性设置的快捷方式"><a href="#属性设置的快捷方式" class="headerlink" title="属性设置的快捷方式"></a>属性设置的快捷方式</h1><p>对于内边距设置：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding-top: 0px;</span><br><span class="line">padding-right: 20px;</span><br><span class="line">padding-bottom: 30px;</span><br><span class="line">padding-left: 10px;</span><br></pre></td></tr></table></figure></p><p>可以使用简写形式将它们写为<code>padding: 0px 20px 30px 10px;</code>。<br><br>这种方法对于外边距同样适用。<br><br>需要注意内边距和外边距简写时的顺序是上，右，下，左（可以想像为一个钟表指针旋转的顺序）。<br><br>如果所有四个边上的内边距或外边距值都相同，还可以更简短：<code>padding: 20px</code>，这说明，盒子四边的内边距都是20像素。<br><br>要简写外边距（或内边距）还有另外一种常用方法：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">margin-top: 0px;</span><br><span class="line">margin-right: 20px;</span><br><span class="line">margin-bottom: 0px;</span><br><span class="line">margin-left: 20px;</span><br></pre></td></tr></table></figure></p><p>上下外边距以及左右外边距分别都是一样的，所以可以简写为：<code>margin: 0px 20px</code>，先写上下，再写左右。<br><br>对于边框属性，我们也可以使用简写：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-width: thin;</span><br><span class="line">border-style: solid;</span><br><span class="line">border-color: #007e7e;</span><br></pre></td></tr></table></figure></p><p>将边框属性重写为一个属性。可以采用你喜欢的任何顺序：<code>border: thin solid #007e7e;</code>。<br><br>背景也可以简写：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-color: white;</span><br><span class="line">background-image: url(images/cocktail.gif);</span><br><span class="line">background-repeat: repeat-x;</span><br></pre></td></tr></table></figure></p><p>类似于边框，简写中这些值可以采用任何顺序，还可以指定另外一些值，如background-position。上述写法可简写为：<code>background: white url(images/cocktail.gif) repeat-x;</code>。<br><br>字体也可以进行简写，字体需要的所有属性有：font-family,font-style,font-weight,font-size,font-variant,还有line-height。有一个简写可以将所有这些属性包装成一个属性。font: font-style font-variant font-weight font-size/line-height font-family。font-size之前的这些属性都是可选的，可以指定这些属性的任意组合，顺序并不重要，不过它们必须出现在font-size属性前面。必须使用font-size属性指定字体大小。line-height属性是可选的。如果你想指定一个行高，只需要在font-size属性后面加一个/，然后指定你想要的行高。最后需要增加字体系列。只需要指定一个字体（必要），不过强烈建议指定一些候选字体。font-family名之间要使用逗号分隔。</p><h1 id="伪类-pseudo-classes"><a href="#伪类-pseudo-classes" class="headerlink" title="伪类(pseudo-classes)"></a>伪类(pseudo-classes)</h1><p>有没有注意到，在样式方面，链接的表现稍有不同。链接的颜色取决于具体环境，它们会瞬间改变样式。一般没有访问过的链接（称为“未访问链接”，或者就称为“链接”），默认地，这个链接是蓝色的。对于一个之前单击过的链接，我们把这种链接称为“已访问的链接”。通常，相对于未访问的链接，已访问的链接会用不同的颜色显示，以便区分二者的差别。大多数浏览器中，已访问的链接默认为紫色。如果把鼠标停在一个链接上面，但不单击，这称为“悬停”。在一些浏览器上，鼠标悬停在链接上时你会看到一个工具提示，它会显示”title”属性的文本，如果你看的更仔细一些，会发现悬停在链接上时它有一种不同的样式。<br><br>那么如何根据元素的状态指定样式，举个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a:link &#123;    /*未访问的链接*/</span><br><span class="line">    color: green;</span><br><span class="line">&#125;</span><br><span class="line">a:visited &#123;    /*已访问的链接*/</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">a:hover &#123;       /*悬停的链接*/</span><br><span class="line">    color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意这里有元素<code>&lt;a&gt;</code>，后面是一个:（冒号），然后是我们想选择的状态。要确保这些选择器中没有空格。<br><br>如果把<code>&lt;a&gt;</code>元素当作一个普通元素来指定样式，比如指定:<code>a { color: red; }</code>，此时你的链接在所有状态下看起来都一样，这会使你的链接无法做到用户友好，因为没有办法区分哪些访问过，哪些没有访问过。<br><br><code>&lt;a&gt;</code>元素还有两种链接状态：focus和active。浏览器将焦点放在你的链接上时就是焦点(focus)状态。这是什么意思？有些浏览器允许按下Tab键来轮流访问页面上的所有链接。浏览器访问到某个链接时，这个链接就拥有“焦点”。设置一个焦点伪类值对于提高可访问性很有帮助，因为需要使用键盘（而不是使用鼠标）来访问链接的人会知道他们何时选择到正确的链接。用户第一次单击一个链接时，就处于活动(active)状态。<br><br>链接可以同时处于多种状态，比如说，我的链接可能已经访问过，而且鼠标悬停在它上面，另外用户正在单击它，这种情况可能同时发生。此时应该应用哪个样式呢？一般要按规则来确定应用哪个样式。所以一般认为适当的顺序是：link,visited,hover,focus,然后是active。<br><br>利用伪类可以创建一些很有意思的选择器。<br><br>a:link,a:visited甚至a:hover都允许你指定样式，就好像它们是类一样，所以这些就是伪类。换句话说，你可以对伪类指定样式，但是没有人在HTML中真正输入这些伪类。<br><br>伪类并不是只能处理链接。现代浏览器已经对其他类型的元素提供了类似:hover等伪类支持，另外还有一些其他的伪类。例如，伪类:first-child对应元素的第一个子元素，如<code>&lt;blockquote&gt;</code>中的第一个段落，甚至还可以用:last-child伪类选择<code>&lt;blockquote&gt;</code>的最后一个段落。<br></p><h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><p>给定一组样式表中的一组样式，浏览器就是以层叠方式来确定具体使用哪一个样式。<br><br>注意，如果读者在一个属性声明的最后加上”!important”，他就能覆盖你的样式。<br><br>浏览器确定要对一个元素应用哪个样式时，它会使用所有这些样式表。最优先的是作者的样式（也就是你的样式），然后是读者的样式，最后才是浏览器的默认样式。<br><br>如何确定一个元素使用哪种样式？让我们来扮演浏览器！</p><p><ol>    <li>收集所有样式表，包括：Web页面作者写的样式表，读者增加的样式表，还有浏览器的默认样式。</li>    <li>找到所有匹配的声明，比如要找该元素的font-size属性，所以要查看所有可能选择该元素的选择器的font-size声明。检查所有样式表，找出所有匹配该元素而且有font-size属性的规则。</li>    <li>现在对所有匹配的规则排序。按作者，读者和浏览器对这些规则排序。换句话说，如果是你（页面的作者）写的规则，它们就比读者写的规则更重要。相应地，读者的样式比浏览器的默认样式更重要。记住，我们提到过，读者可能在他的CSS上加上!important，如果是这样，排序时这些属性最为优先。</li>    <li>现在按特定性对所有声明排序（三种规则的组内排序），要计算特定性，利用一个三位数000，先判断这个选择器包含id吗，每个id在百位上加1分。再判断这个选择器包含类或伪类吗，每个类或伪类在十位上加一分，最后判断这个选择器包含元素名吗，一个元素名在个位上加一分。该三位数的值越大，特定性越高。</li>    <li>最后，对于冲突的规则（此时还是判断是否组内发生冲突），按照它们在各自样式表中出现的顺序进行排序。各个样式表中后出现的规则（更靠近最下面）更重要。所以，如果在样式表中增加一个新规则，它会覆盖它之前的所有规则。</li></ol><br>第三条关于”!important”的内容：读者可能会覆盖一个样式，在他的属性声明最后放置一个”!important”，就像这样:<code>h1 { font-size: 200%;      !important;}</code>，这会覆盖作者的样式。<br><br>针对第四条中计算特定性的方法，可能会有这么一个疑问，类似”h1, h2”的规则的特定性是多少呢？可以把它看作是两个单独的规则：一个”h1”规则，特定性为”001”，还有一个”h2”规则，特定性也为”001”。<br><br>如果在层叠的所有规则中都没有找到匹配的属性，就要使用继承了。并不是所有属性都能继承，比如边框属性。不过，对于能继承的属性（如color,font-family,line-height等），浏览器会查看这个元素的祖先，从它的父元素开始，尝试找到这个属性的值。如果找到了，这就是你要用的属性值。<br><br>但是如果这个属性不能继承呢？或者如果在祖先元素的规则中找不到这样一个值呢？就只能靠浏览器样式表中设置的默认值了，所有浏览器都应该对每个元素设置了默认值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>&lt;div&gt;</code>元素用于将相关的元素归组在一起，放在逻辑区中。</li><li>创建逻辑区有助于标志主内容区以及页面的页眉和页脚。</li><li>可以使用<code>&lt;div&gt;</code>元素为文件增加很多结构，这有利于保证结构清晰或者方便增加样式。不过除非确实需要，否则不要过多地增加结构。</li><li>一旦用<code>&lt;div&gt;</code>元素将内容区归组在一起，类似于其他块元素，可以对这些<code>&lt;div&gt;</code>增加样式。例如，对于包含在<code>&lt;div&gt;</code>中的一组元素，可以使用嵌入这些元素的<code>&lt;div&gt;</code>的边框属性，对这组元素增加一个边框。</li><li>width属性设置一个元素内容区的宽度。</li><li>一个元素的总宽度是内容区宽度，加上所增加的内边距，边框或外边距的宽度。</li><li>一旦设置一个元素的宽度，它不会延伸来占满浏览器窗口的整个宽度。</li><li>text-align是块元素的一个属性，用来将这个块元素中的所有内容对齐，可以居中，左对齐或右对齐。这个属性可以由所有嵌套的块元素继承。</li><li>可以使用子孙选择器来选择嵌套在其他元素中的元素。例如，子孙选择器 <code>div h2 {...}</code>，会选择嵌套在<code>&lt;div&gt;</code>元素中的所有<code>&lt;h2&gt;</code>（包括子元素，孙子元素等）。</li><li>可以对相关的属性使用快捷方式。例如，padding-top,padding-right,padding-bottom,padding-left都和内边距有关，可以使用一个快捷规则来指定：padding。</li><li>内边距，外边距，边框，背景和字体属性都可以用快捷方式指定。</li><li><code>&lt;span&gt;</code>内联元素与<code>&lt;div&gt;</code>元素类似，它用于将相关的内联元素和文本归组在一起。</li><li>类似于<code>&lt;div&gt;</code>，可以将<code>&lt;span&gt;</code>元素增加到类（或者为<code>&lt;span&gt;</code>元素指定唯一的id），对它们增加样式。</li><li>有些元素有不同的状态，<code>&lt;a&gt;</code>元素就是这样一个例子。<code>&lt;a&gt;</code>元素的主要状态包括未访问，已访问和悬停。</li><li>可以用伪类单独地对各个状态指定样式。伪类最常用于<code>&lt;a&gt;</code>元素，:link对应未访问的链接，:visited对应已访问的链接，:hover对应悬停状态。</li><li>伪类还可以用于其他元素，而不仅限于<code>&lt;a&gt;</code>。</li><li>另外一些伪类包括:hover,:active,:focus,:first,:first-child和:last-child伪类等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML与CSS（九）</title>
      <link href="/2019/03/01/HTML%E4%B8%8ECSS(%E4%B9%9D)/"/>
      <url>/2019/03/01/HTML%E4%B8%8ECSS(%E4%B9%9D)/</url>
      
        <content type="html"><![CDATA[<p>盒模型由内容区(context area)，内边距(padding)，边框(border)和外边距(margin)组成<br><br>内边距和外边距只能调整大小（可以使用像素或百分数）<br><br>边框可以设置样式，宽度，颜色，圆角<br><br>内边距，外边距可以调整任意一边的大小，边框可以调整任意一边的宽度<br><br>使用line-height属性调整行间距（可以使用像素或百分数或em，相对于字体大小指定）<br><br>还可以设置背景图像，以及设置背景图像是否重复，背景图像摆放位置<br><br>id属性的使用<br><br>使用混合样式表来控制不同设备用不同的样式显示页面（多个<code>&lt;link&gt;</code>元素或用@media规则）<br><a id="more"></a><br>今天出去玩啦，和室友吃了海底捞。大家都拍照修图超级棒！我也要好好学ps嘻嘻。</p><h1 id="盒模型-box-model"><a href="#盒模型-box-model" class="headerlink" title="盒模型(box model)"></a>盒模型(box model)</h1><p>盒模型是CSS看待元素的一种方式。CSS将每个元素看作由一个盒子表示。每个盒子由一个内容区以及可选的内边距，边框和外边距组成。<br><br>内容区(content area)包含内容，例如文本或图像。<br><br>内容区被可选的透明内边距(padding)包围。<br><br>内边距周围可能放置一个可选的边框(border)。<br><br>最后，有一个可选的透明外边距(margin)包围所有部分。<br><br>可以把内边距看作元素的一部分，而外边距包围你的元素，将它与其它元素分开。<br><br>内边距，边框和外边距都是可选的，相互之间没有依赖关系。可以有一个边框而没有内边距，或者可以由一个外边距而没有边框，这些都是可以的。<br><br>除了大小，不能对内边距和外边距指定样式。由于他们是透明的，所以他们会呈现背景颜色或背景图像。内边距和外边距之间有一个区别：元素的背景颜色（或背景图像）会延伸到内边距下面，但不会延伸到外边距。<br><br>如果需要在内容区本身周围有更大的可见空间，就要使用内边距，另一方面，如果希望元素与页面边缘之间有更大空间，这种情况下就要使用外边距。<br><br>所有元素都被当作盒子，段落，标题，块引用，列表，列表项等。甚至内联元素（如<code>&lt;em&gt;</code>和链接）在CSS看来也是盒子。<br><br>利用CSS，你可以对盒子的所有方面加以控制：内容周围内边距的大小，元素是否有边框（什么类型的边框以及边框的大小），另外元素之间有多大的外边距。<br></p><h2 id="内容区"><a href="#内容区" class="headerlink" title="内容区"></a>内容区</h2><p>每个元素都会有一些内容，如文本或图像，这个内容会放在一个盒子里，这个盒子的大小正好能包含所有内容。注意，在内容区中，内容与盒子边缘之间没有空间（盒子的边缘也就是边界实际上是看不到的）。<br></p><h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>所有盒子在内容区周围可能有一层内边距。内边距是可选的，所以不一定有，不过通过使用内边距，可以在内容与盒子边框之间创建一些看得到的空间。内边距是透明的，没有颜色，也没有自己的装饰。<br><br>CSS有一个padding属性，可以用来对内容四周设置相同的内边距。可以将这个属性设置为一个像素数，或者也可以设置为一个百分数。<br><br>CSS在每个方向（上，下，左和右）都提供了内边距的一个属性。要在左边增加内边距，可以使用padding-left属性。</p><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>元素周围可以有一个可选的边框。这个边框会包围内边距，另外，因为它是围绕内容的一条线，这就从视觉上使内容与同一页面上的其他元素隔开。边框可以有各种不同颜色的宽度，颜色和样式。<br><br>border-style属性可以控制边框的视觉样式，共有八种可用的边框样式：solid（实线），double（双线），groove（槽线），outset（外凸），dotted（虚线），dashed（破折线），inset（内凹），ridge（脊线）。<br><br>border-width属性控制边框的宽度。可以使用关键字（thin,medium,thick）或像素来指定边框宽度。不过需要注意不同浏览器对thin，medium和thick的具体大小可能有不同的定义。所以如果边框大小对你来说确实很重要，就应该考虑使用像素大小来指定。<br><br>border-color属性设置边框的颜色。这与设置字体颜色相似，可以使用颜色名，rgb值或十六进制码来指定颜色。<br><br>就像外边距和内边距一样，还可以指定任意一边（上，下，左和右）的边框样式，宽度和颜色。举个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-top-color: black;</span><br><span class="line">border-top-style: dashed;</span><br><span class="line">border-top-width: thick;</span><br></pre></td></tr></table></figure></p><p>还可以利用border-radius属性指定边框圆角，可以在四个角上都创建圆角，或者只对一个角或这四个角的任意组合创建圆角。可以用一个数指定4个角：<code>border-radius: 15px;</code>，或者，可以分别指定每一个角。注意你可以使用px或em来指定半径大小。例如：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-top-left-radius: 15px;</span><br><span class="line">border-top-right-radius: 0px;</span><br><span class="line">border-bottom-right-radius: 0px;</span><br><span class="line">border-bottom-left-radius: 15px;</span><br></pre></td></tr></table></figure></p><p>注意写属性的时候先确定上下，再确定左右。如果使用em，边框半径的度量相对于元素的字体大小，与使用em指定font-size时是一样的。<br></p><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>外边距也是可选的，包围着边框。利用外边距，可以在同一个页面上的不同元素之间增加空间。如果两个盒子紧挨着，外边距就相当于它们之间的空间。类似于内边距，外边距也是透明的，本身没有颜色或装饰。<br><br>CSS有一个margin属性，可以用来对整个段落四周设置相同的外边距。可以将这个属性设置为一个像素数，或者也可以设置为一个百分数。<br><br>与处理内边距一样，CSS在每个方向（上，下，左和右）都提供了外边距的一个属性。可以增加另一个属性margin-right来增加右外边距。<br><br>内外边距设置的规律是首先有一个属性来控制所有4个边，另外如果你想单独对每个边进行设置，实际上对每个边还分别有一个属性。<br></p><h1 id="调整行高"><a href="#调整行高" class="headerlink" title="调整行高"></a>调整行高</h1><p>line-height属性可以用于调整页面上文本的行高，使得各行之间有更大的垂直间距。<br><br>增加文本的行高可以改善可读性。这样做还可以使页面不同部分之间形成对比，产生反差。<br><br>line-height属性允许你指定文本中各行之间的垂直间距量。类似于其它与字体相关的属性，可以按像素指定行高，也可以使用em或百分数值相对于字体大小来指定。<br><br>在出版社行业中，行之间的间距也称为“行间距”（leading）。</p><h1 id="增加背景图像"><a href="#增加背景图像" class="headerlink" title="增加背景图像"></a>增加背景图像</h1><p>如果要在元素的背景上增加一个图像，可以使用background-image属性为任何元素增加一个背景图像。比如说：<code>background-image: url(images/background.gif);</code>。<br>background-image属性设置为一个URL，这可以是一个相对路径，也可以是一个完整的URL。注意URL两边不需要加引号。<br><br>background-image和<code>&lt;img&gt;</code>元素的差别：background-image属性用途非常特定，它只是要设置一个元素的背景图像。这个属性并不是用来在页面中放置图像，要想放置图像，就需要使用<code>&lt;img&gt;</code>元素。也可以这样来考虑二者的区别：背景图像属于表现方面，使用background-image属性的唯一理由就是要让元素更有吸引力。另一方面，<code>&lt;img&gt;</code>元素则用来包含一个图像，它在页面中可能有更为重要的作用，如照片和logo。<br><br>类似于背景颜色，这些背景图像也只出现在内容区和内边距下面，不会在边框以外或外边距中出现。<br><br>background-image属性把一个图像放在元素的背景中。还有另外两个属性也会影响背景图像：background-position和background-repeat。默认地，背景图像会重复。好在background-repeat属性中有一个no-repeat值。另外，浏览器还会默认地把背景图像放在元素的左上角。<br><br>background-position属性会设置图像的位置，可以按像素指定，也可以指定为一个百分数，或者还可以使用关键字指定，如top,left,right,bottom和center。举个例子：<code>background-position: top left;</code>，这指定将这个图像放在元素的左上角。<br><br>默认地，背景图像会“平铺”，也就是反复重复来填满整个背景空间。background-repeat属性可以控制这种平铺行为。其对应的属性值有五个：repeat（设置图像在水平和垂直方向重复，这个是默认值）,no-repeat（图像显示一次，根本不重复）,repeat-x（图像只在水平方向上重复）,repeat-y（图像只在垂直方向上重复）,inherit（按父元素的设置来处理）。</p><h1 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h1><p>为元素指定id与将元素增加到一个类很类似。唯一的区别是，这个属性名为id，而不是class，一个元素不能有多个id，另外页面上不允许多个元素有相同的id。<br><br>id只是一个元素的唯一标识符，不过这并不妨碍这个元素属于一个或多个类。<br><br>要按id来选择一个元素，需要在id前面使用一个#字符（可以与类做个比较，按类选择时，需要在类名前使用一个点号[.]）。如果想选择id为footer的任意元素： <code>#footer { color: red; }</code>。或者可以只选择id为footer的一个<code>&lt;p&gt;</code>元素：<code>p#footer { color: red; }</code>。class与id还有一点区别：id选择器只与页面的一个元素匹配。<br><br>可能会产生这么一个疑问，为什么会选择id为footer的一个<code>&lt;p&gt;</code>元素呢，不是页面上不允许多个元素有相同的id吗？注意是一个页面上不允许多个元素有相同id。但是对于两个不同的页面，可以对两个页面上的不同的元素指定同一id，如果这两个页面使用的是同一个CSS文件的话就需要p#footer这种形式的选择器。<br><br>类和id名的规则：类名要以一个字母开头，不过id名可以以一个数字或字母开头。id和类名都可以包含字母，数字以及_字符，但不能有空格。一定要记住，id必须是唯一的！</p><h1 id="混合样式表"><a href="#混合样式表" class="headerlink" title="混合样式表"></a>混合样式表</h1><p>可以指定一组样式表用于任何HTML。也就是说，在你的HTML中有多个<code>&lt;link&gt;</code>元素，要注意的是顺序很重要，一个样式表会覆盖在它上面链接的样式表中的样式。<br><br>有时会有一个样式表作为页面的基础样式。要修改样式，并不是修改这个样式表，而是链接这个样式表，然后在它下面创建你自己的样式表，指定你想修改的样式。<br><br>之所以希望有多个样式文件，实际上还有一个原因：你可能针对将要显示页面的设备类型（桌面PC，笔记本电脑，平板电脑，手机或者甚至页面的印刷版本）来调整页面的样式。此时可以利用一个media属性，在<code>&lt;link&gt;</code>元素中增加这个属性，只是用适用于指定设备的样式文件。比如说：<br><code>link href=&quot;lounge-mobile.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width: 480px)&quot;</code>。media属性允许你指定应用这个样式表的设备类型，通过创建一个“媒体查询”来指定设备类型，媒体查询要与设备匹配，这个查询指定了有屏幕的设备（而不是其他设备，比如打印机或3D眼镜，或者盲文阅读机），而且屏幕宽度不得超过480像素。<br><br>查询中还有许多属性可以使用，如min-device-width,max-device-width以及显示方向[orientation，这可以是横向(landscape)或纵向(portrait)]。要记住，可以根据需要为HTML增加多个<code>&lt;link&gt;</code>标记，涵盖你要支持的所有设备。也就是说你可以建立多个样式表，然后在你的HTML中链接这些样式表，这个工作可以交给浏览器来完成，它会根据媒体类型和你在媒体查询中指定的特征选择使用合适的样式表。<br><br>也可以直接在CSS中增加媒体查询，举个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-device-width: 481px) &#123;</span><br><span class="line">    #guarantee  &#123;</span><br><span class="line">margin-right: 250px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-device-width: 480px) &#123;</span><br><span class="line">    #guarantee  &#123;</span><br><span class="line">margin-right: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media print &#123;</span><br><span class="line">    body  &#123;</span><br><span class="line">font-family: Times, &quot;Times New Roman&quot;, serif;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.specials &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意写法为@media规则后面是你的媒体类型，然后对于与这个查询匹配的设备，然后将所有适用的规则放在大括号里。<br><br>@media规则只包含特定于一种媒体类型的CSS规则。在CSS文件中，要把对所有媒体类型都通用的规则放在@media规则下面（比如上面的p.specials），这样一来，就不会不必要地重复规则了。<br><br>max-device-width和min-device-width媒体属性依赖于设备的实际屏幕（而不是你的浏览器窗口宽度）。如果你更关心浏览器窗口大小的话可以使用max-width和min-width属性，它们表示浏览器窗口本身的最大和最小宽度（而不是屏幕大小）。<br><br>IE8及以前版本不支持媒体查询。<br><br>多个<code>&lt;link&gt;</code>元素和@media规则哪个更好？如果你的CSS文件相当庞大，我们就建议使用<code>&lt;link&gt;</code>元素来指定不同的样式表。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>CSS使用一个盒模型来控制元素如何显示。</li><li>盒子由内容区和可选的内边距，边框和外边距组成。</li><li>内容区包含元素的内容。</li><li>内边距用来在内容区周围创建可见的空间。</li><li>边框包围内边距和内容，它提供了从视觉上分离内容的一种手段。</li><li>外边距包围边框，内边距和内容，允许在元素和其它元素之间增加空间。</li><li>内边距，边框和外边距都是可选的。</li><li>元素的背景会在内容和内边距下显示，但不会延伸到外边距下面。</li><li>内边距和外边距大小可以用像素或百分数设置。</li><li>边框宽度可以用像素设置，也可以使用关键字thin,medium和thick来指定。</li><li>有八种不同的边框样式，包括实线，破折线，虚线和脊线。</li><li>对于外边距，内边距或边框，CSS提供了相应属性，可以一次对所有四个边（上，下，左，右）完成设置，也可以单独设置任意一边。</li><li>使用border-radius属性可以对有边框的元素创建圆角。</li><li>使用line-height属性可以增加文本行之间的间距。</li><li>可以用background-image属性在元素的背景上放置图像。</li><li>使用background-position和background-repeat属性可以设置背景图像的位置和平铺行为。</li><li>对于希望成组指定样式的元素要使用class属性。</li><li>使用id属性为元素指定一个唯一的名字。还可以使用id属性为元素提供唯一的样式。</li><li>一个页面上有给定id的元素只能有一个。</li><li>可以使用id选择器按id选择元素。例如#myfavoriteid。</li><li>一个元素只能有一个id，不过它可以属于多个类。</li><li>在HTML中可以使用多个样式表。</li><li>如果两个样式表包含冲突的属性定义，HTML文件中最后链接的样式表最为优先。</li><li>可以在<code>&lt;link&gt;</code>元素中使用媒体查询或者使用CSS中的@media规则来指定设备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(八)</title>
      <link href="/2019/02/28/HTML%E5%92%8CCSS(%E5%85%AB)/"/>
      <url>/2019/02/28/HTML%E5%92%8CCSS(%E5%85%AB)/</url>
      
        <content type="html"><![CDATA[<p>五种字体系列介绍，怎么设置字体，以及Web字体的使用<br>调整字体大小的四种方法<br>调整字体粗细<br>设置字体倾斜<br>指定Web颜色的三种方法<br>如何为文本增加装饰<br><a id="more"></a><br>今天的我又不想学习了（´ο｀）。</p><h1 id="增加字体和颜色样式"><a href="#增加字体和颜色样式" class="headerlink" title="增加字体和颜色样式"></a>增加字体和颜色样式</h1><ul><li>可以使用font-family属性定制页面中使用的字体，可以创建一个首选字体列表，并且还可以扩展浏览器可用的字体。</li><li>用font-size属性可以控制字体的大小。</li><li>用color属性可以为文本设置颜色。</li><li>用font-weight属性影响字体的粗细。该属性对应的属性值有lighter,normal,blod,bloder。</li><li>使用text-decoration属性可以对文本增加一些装饰，包括上划线，下划线和删除线，其对应的属性值分别为overline,underline和line-through，也可以指定其什么线都不加，属性值为none。<h2 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h2>每个font-family包含一组有共同特征的字体。共有5个字体系列:sans-serif,serif,monospace,cursive和fantasy。每个字体系列都包含大量字体。<br><p></p></li><li>sans-serif字体系列包括没有衬线的字体。与serif字体相比，通常认为sans-serif字体在计算机上更容易识别。</li><li>serif字体系列包括有衬线（衬线是字母末端的装饰性“小细线”）的字体。很多人一看到这种字体就想到新闻报纸的文字排版。</li><li>monospace字体系列中的字体包含固定宽度的字体。例如，一个”i”在水平方向所占的宽度与一个”m”所占的宽度是相同的。这些字体主要用于显示软件代码示例。</li><li>cursive字体系列包括看似手写的字体。有时会看到标题中使用这些字体。</li><li>fantasy字体系列包含有某种风格的装饰性字体。<br>&lt;/p&gt;<h3 id="使用CSS指定字体系列"><a href="#使用CSS指定字体系列" class="headerlink" title="使用CSS指定字体系列"></a>使用CSS指定字体系列</h3>使用font-family属性可以指定多个字体。只需要输入字体名，并用逗号分隔。需要注意的是字体名大小写敏感。通常，你指定的font-family包含一个候选字体列表，它们都来自同一个字体系列。最后总是放一个通用的字体系列名。<br><br>举个例子：<code>body {  font-family: Verdana, Geneva, Arial, sans-serif; }</code><br><br>font-family规范在工作时，先查看用户计算机上是否有Verdana字体，如果有，这个元素（即<code>&lt;body&gt;</code>元素就会使用这个字体）。如果第一个字体不可用就看下一个是否可用，直到找到一个可用的字体或者到最后一个字体系列，使用浏览器的默认该字体系列的字体。<br><br>如果字体名中有空格，就需要对该字体名加引号。例如：<code>font-family: &quot;Courier New&quot;, Courier;</code><br><br>一般对于最后一个字体，应当指定最全面的通用”sans-serif”或”serif”，它与列表中指定的所有其他字体应当在同一个字体系列中。<br><h3 id="使用Web字体"><a href="#使用Web字体" class="headerlink" title="使用Web字体"></a>使用Web字体</h3>如果你必须使用某种比较好的字体，或者排版对你的网站设计很重要，那么你可以使用Web字体（Web Font）向用户的浏览器提供一种字体。<br><br>这要用到CSS的一个特性: <strong>@font-face规则</strong>。这个规则允许你定义一种字体的名字和位置，然后可以在你的页面中使用。<br><br>Web字体的工作过程如下：<br><ol>  <li>要利用Web字体，浏览器首先获取一个引用这些字体的HTML页面。</li>  <li>浏览器再获取这个页面所需的Web字体文件（字体文件包含在Web页面中使用这种字体时浏览器所需的一切信息，字体文件应当放在服务器上或者使用托管服务，当然，测试时可以本地测试）。</li>  <li>在获取了这个字体以后，浏览器显示页面时就会使用这个字体。</li></ol><br>为页面增加Web字体的方法如下：<br><ol>  <li>找到一个字体，可以访问一些提供字体的网站，它们会提供免费以及需要授权的字体。</li>  <li>确保有所需字体的所有格式，存储字体的具体格式目前还不是一个标准，不同的浏览器对很多不同的格式提供了不同程度的支持，常用的格式有：TrueType字体(.ttf)，OpenType字体(.otf)，Embedded Open Type字体(.eot)，SVG字体(.svg)，Web开放字体格式(.woff)。大多数现代浏览器上支持最为广泛的格式时Web开放字体格式。</li>  <li>将所需的字体文件放在Web上，这样用户的浏览器就能访问这些字体。</li>  <li>在CSS中增加@font-face属性</li>  <li>在CSS中使用font-family名</li>  <li>加载页面</li></ol><br>@font-family规则使用举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">font-family: &quot;Emblema One&quot;;</span><br><span class="line">src: url(&quot;EmblemaOne-Regular.woff&quot;), </span><br><span class="line">     url(&quot;EmblemaOne-Regular.ttf&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此处用了相对地址。<br><br>该规则要以@font-family开头。与正常的规则不同，正常的规则会选择一组元素并指定样式，而@font-family规则会建立一个字体，将指定一个font-family名，以便以后使用。在这个规则中，我们使用font-family属性为这个字体创建一个名字。可以使用你喜欢的任何名字，不过通常最好与字体名一致。src属性告诉浏览器在哪里可以得到这个字体。对于浏览器可识别的每一个文件，我们要分别指定一个src值。<br><br>@font-face规则告诉浏览器：要加载由src URL指定的字体文件。浏览器会尝试加载每一个src文件，直到找到它能支持的一个文件。一旦加载，会为这个字体分配font-family属性中指定的名字，在这里就是”Emblema One”，然后就可以在其他地方指定这种字体了。<br><br>@font-face规则不像前面学的CSS规则，可以认为@font-face是一个内置的CSS规则，而不是一个选择器规则。@font-face并不选择一个元素。利用@font-face规则，可以获取一个Web字体，并为它分配一个font-family名。最前面的@就说明它不是一个普通的CSS规则。还有两个常用的内置CSS规则，分别是@import和@media。@import允许导入其他CSS文件（而不是HTML中通过一个<code>&lt;link&gt;</code>链入），另外@media允许创建特定于某些“媒体”类型的CSS规则。<br><br>可以用@font-face使用多个定制字体。如果使用@font-face来加载字体，对于你想要的每一种字体，要确保服务器上有相应的字体文件，而且要为每个字体创建一个单独的@font-face规则，所以对各个字体要分别指定唯一的名字。<br></p><h2 id="调整字体大小"><a href="#调整字体大小" class="headerlink" title="调整字体大小"></a>调整字体大小</h2><p></p><p>指定字体大小有很多选择：px, em, 百分数和关键字。</p><p></p><ul><li>按像素指定字体大小是在告诉浏览器字母高度是多少像素。比如说：<code>font-size: 14px;</code>，这指定了字母是14像素高。</li><li>用一个百分数指定大小时，会相对于其父元素的字体大小指出这个字体有多大。比如说：<code>body {  font-size: 14px; }     h1  { font-size: 150%; }</code>。</li><li>还可以使用em指定字体大小，类似于百分数，这也是一个相对度量单位。使用em时，不是指定一个百分数，而是要指定一个比例因子。举个例子：<code>font-size: 1.2em;</code>。</li><li>还可以使用关键字将一个字体大小指定为xx-small,x-small,small,medium,large,x-large,xx-large，浏览器会把这些关键字转换为像素值，它会使用浏览器中定义的默认值来完成这个转换。这些关键字之间的大小关系为每个大小大约比前一个大小大20%，small通常定义为大约12像素。不过，各个浏览器对这些关键字的定义并不一定相同，如果用户愿意，他们还可能重新给出他们自己的定义。<h3 id="如何指定字体大小"><a href="#如何指定字体大小" class="headerlink" title="如何指定字体大小"></a>如何指定字体大小</h3>利用以下方法，可以在大多数浏览器中得到一个一致的结果：<br><ol>  <li>选择一个关键字（推荐small和medium），指定它作为body规则中的字体大小。这相当于页面的默认字体大小。</li>  <li>使用em或百分数，相对于body字体大小指定其他元素的字体大小（选择em还是百分数由自己决定，因为实际上这两种方法作用是一样的）。</li></ol><br>这样做的好处是：如果相对于body字体大小定义其他元素的字体大小，那么改变Web页面中的字体大小就会很容易，只需要改变body字体大小就可以了。如果你想重新设计页面，使字体更大一些的话，如果此时你的body字体值大小为small，只需要把它改为medium。此时每一个元素都会自动按比例放大，因为它们的字体大小是相对于body字体大小指定的。并且如果用户想调整页面上的字体大小时，同样的，利用这个方法，页面上的所有字体都会自动调整大小。<br><br>如果使用像素指定字体大小，老版本的Internet Explorer将不支持文本缩放。<br><br>在body规则中也可以使用em或%，如果在body规则中指定字体大小为90%，这将是默认字体大小的90%。如果你希望一个字体大小与关键字指定的大小稍有区别，就可以使用%或em。<br><h2 id="调整字体粗细"><a href="#调整字体粗细" class="headerlink" title="调整字体粗细"></a>调整字体粗细</h2>font-weight属性允许你控制文本的粗细，粗体文本看起来比正常文本更深，而且往往要“胖”一点。可以将元素的font-weight属性设置为bold，来使用粗体文本。也可以反过来。如果一个元素默认地设置为bold，或者从父元素继承了粗体可以将其font-weight属性设置为normal来去掉粗体样式。<br><br>还有两个相对font-weight属性：bolder和lighter。使用这两个属性值时，会相对于所继承的值使文本样式稍粗一些或稍细一些。这些值很少使用，因为没有多少字体支持粗细程度的微小差别，实际上这两个值通常没有任何效果。<br><br>也可以将font-weight属性值设置为100到900之间的一个数（100的倍数），不过同样的，这个特性也未得到字体和浏览器的广泛支持。<br><h2 id="设置字体倾斜"><a href="#设置字体倾斜" class="headerlink" title="设置字体倾斜"></a>设置字体倾斜</h2>在CSS中可以使用font-style属性为文本增加斜体风格：<code>font-style: italic;</code>，斜体文本会向右倾斜，另外衬线还有弯曲。<br><br>不过，并不是所有字体都支持斜体风格(italic)，所以你得到的实际上称为倾斜(oblique)文本。倾斜文本也是倾斜的，不过这种字体并不是使用一组专门设计的倾斜字符，而是由浏览器将正常文字倾斜。<br><br>也可以使用font-style属性得到倾斜文本：<code>font-style: oblique;</code>。<br><br>除非可以控制用户使用的字体和浏览器，否则你会发现，不论你指定什么风格，结果并不确定，有时你会得到斜体，有时则是倾斜文本。所以完全可以就用斜体，不用担心它们的差别（你可能根本无从控制）。<br><h2 id="Web颜色"><a href="#Web颜色" class="headerlink" title="Web颜色"></a>Web颜色</h2>Web颜色是按构成颜色的红，绿，蓝三个分量所占数量来指定的。每种颜色会分别指定一个从0到100%的数值，然后把它们混合起来得到最终的颜色。例如：如果把红色100%，绿色100%和蓝色100%混合在一起，就会得到白色。注意，在计算机屏幕上，将颜色混合在一起将会得到一种更亮的颜色。<br><br>如果三个颜色分量各60%，混合在一起就会得到一个灰色，因为我们仍然是将这三种颜色等量相加，不过没有那么多光发送到屏幕上。<br><br>如果把红色80%和绿色40%混合在一起，就会得到一个橙色。<br><br>如果红，绿和蓝色都是0%，混合在一起就会得到黑色。因为根本没有向屏幕发送任何光，所以会得到黑色。<br><h3 id="如何指定Web颜色"><a href="#如何指定Web颜色" class="headerlink" title="如何指定Web颜色"></a>如何指定Web颜色</h3><p>CSS提供了很多种指定颜色的方法。可以指定颜色名，或者按红，绿，蓝相对百分比指定颜色，也可以使用一个十六进制码指定颜色，这是描述颜色红，绿，蓝分量的一种简写形式。**所有这些指定颜色的方法都是在告诉浏览器这个颜色中红，绿，蓝分量是多少**。</p></li><li>按颜色名指定Web颜色。CSS中有16种基本颜色和150种扩展颜色可以采用这种方法指定。并且CSS颜色名是不区分大小写的。</li><li>还可以按红，绿，蓝分量的多少来指定一个颜色。可以用百分数来指定分量多少，举个例子：<code>body { background-color: rgb(80%, 40%, 0%); }</code>。也可以将红，绿，蓝值指定为0到255之间的一个数值。前面指定的颜色也可以写为：<code>body { background-color: rgb(204, 102, 0); }</code>。因为255的80%就是204，255的40%就是102，255的0%当然是0。</li><li>也可以使用十六进制码指定颜色：一个十六进制码中，每组2位数字分别代表颜色的红，绿，蓝分量。所以前两位数字表示红色，接下来两位表示绿色，最后两位表示,蓝色。就想这样：<code>#cc6600</code>，十六进制码总是以#开头。这表示红色分量的值为204，绿色分量的值为102，蓝色分量的值为0。<br><p>在十六进制码表示颜色的方法中，如果每一组分量中两位数字都相同，那么就可以使用简写。例如，`#ccbb00`可以缩写为`#cb0`。</p><h3 id="如何找到Web颜色"><a href="#如何找到Web颜色" class="headerlink" title="如何找到Web颜色"></a>如何找到Web颜色</h3></li><li>使用类似Photoshop CS的应用。</li><li>使用在线颜色表。通过搜索”HTML color charts”（HTML颜色表），可以找到很多颜色表。<br><p>颜色搭配技巧：对于文本和背景，要使用对比度最大的颜色，这样能提高可读性。例如，白色背景上的黑色文本对比度就最高。也可以尝试让文本使用深色，而背景使用浅色。</p><h2 id="为文本增加装饰"><a href="#为文本增加装饰" class="headerlink" title="为文本增加装饰"></a>为文本增加装饰</h2>要为文本增加一些装饰性效果，如下划线，上划线和删除线，只需要设置元素的text-decoration属性。<br><br>一次可以设置多个装饰。假设你想同时对一个元素加下划线和上划线，可以如下指定文本装饰：<code>em { text-decoration: underline overline; }</code>。<br><br>如果文本继承了你不想要的文本装饰，可以使用”none”来去除装饰：<code>em { text-decoration: none; }</code>。<br><br>如果一个元素有两个不同的规则，一个指定了上划线，另一个指定了下划线，它们不会累加。对于text-decoration只会选择一个规则，不同规则中的装饰不会累加在一起。只有为text-decoration样式选择的规则才能确定使用什么装饰，所以要得到这两个装饰，唯一的办法就是在同一个text-decoration声明中同时指定。<br><br>HTML还提供了一个我们没有谈到的元素：<code>&lt;del&gt;</code>，它能把HTML中的某些内容标记为要删除的内容。还有一个类似的元素，名为<code>&lt;ins&gt;</code>，这会标记要插入的内容。通常浏览器会分别用一个删除线和下划线指定这些元素的样式。通过使用<code>&lt;del&gt;</code>和<code>&lt;ins&gt;</code>，在指定样式的同时还可以指出内容的含义。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>CSS提供了很多属性对字体的外观加以控制，包括font-family,font-weight,font-size和font-style。</li><li>font-family是一组有共同特征的字体。</li><li>用于Web的字体系列包括serif,sans-serif,monospace,cursive和fantasy。serif和sans-serif字体最为常用。</li><li>访问者在你的Web页面上看到的字体取决于他们自己的计算机上安装了哪些字体，除非你使用Web字体。</li><li>在font-family CSS属性中指定候选字体是一个好主意，以防用户没有安装你的首选字体。</li><li>最后一个字体要指定为一个通用字体，如serif或sans-serif，这样一来，如果找不到其他字体，浏览器就可以替换适当的字体。</li><li>如果你要使用某种字体，而默认情况下用户可能没有安装这种字体，可以在CSS中使用@font-face规则。</li><li>字体大小通常使用像素，em，百分数或关键字指定。</li><li>如果使用像素（”px”）来指定字体大小，就是在告诉浏览器字母高度是多少像素。</li><li>em和%是相对字体大小，所以使用em和%指定字体大小时，就意味着字体大小要相对于其父元素的字体大小指定。</li><li>使用相对字体大小可以让你的页面更可维护。</li><li>在body规则中使用字体大小关键字来设置基本字体大小，这样如果用户希望文本更大或更小，所有浏览器就能按比例缩放字体大小。</li><li>可以使用font-weight CSS属性设置文本为粗体。</li><li>font-style属性用于创建斜体或倾斜文本。斜体或倾斜文本是倾斜的。</li><li>Web颜色是混合不同数量的红，绿，蓝色得到的。</li><li>可以使用百分数，0~255的数值或者十六进制码来指定Web颜色。</li><li>要找到你想要的一个颜色的十六进制码，有一种很容易的方法，可以使用一个照片编辑应用的颜色选择工具，或者某个在线Web工具，这样的工具有很多。</li><li>表示颜色的十六进制码有6位，每一位取值为0~F。前两位表示红色数量，接下来两位表示绿色数量，最后两位表示蓝色数量。</li><li>可以使用text-decoration属性为文本创建一个下划线。有下划线的文本通常会被用户误认为是链接文本，所以要谨慎使用这个属性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(七)</title>
      <link href="/2019/02/26/HTML%E5%92%8CCSS(%E4%B8%83)/"/>
      <url>/2019/02/26/HTML%E5%92%8CCSS(%E4%B8%83)/</url>
      
        <content type="html"><![CDATA[<p>如何利用<code>&lt;style&gt;</code>元素给某种元素增加样式<br>利用样式表给多个页面增加样式<br>继承与覆盖继承<br>利用类为单独的段落指定样式<br>CSS验证工具以及常用属性<br>在CSS中写注释，只需要把注释包围在/*和*/之间。<br><a id="more"></a><br>这几天一直在纠结要考研吗(ಥ﹏ಥ)，有点没有勇气。</p><h1 id="给某种元素增加样式"><a href="#给某种元素增加样式" class="headerlink" title="给某种元素增加样式"></a>给某种元素增加样式</h1><p>比如说给<code>&lt;p&gt;</code>元素增加背景色和边框：<code>p    {   background-color: red; border: 1px solid gray;   }</code>，这为<code>&lt;p&gt;</code>元素增加了红色的背景色以及粗细为1像素，灰色，实线的边框。<br><br>然后要将上述CSS放入HTML。要为HTML直接增加CSS样式，需要在<code>&lt;head&gt;</code>元素中增加开始和结束style标记。CSS规则要放在<code>&lt;style&gt;</code>元素之间。<br><br>如果要改变段落中文本的颜色，CSS规则将写为<code>p  { color: red; }</code>，改变字体颜色的属性名为color。<strong>在改变了段落的文本颜色之后，其中链接的颜色不会发生改变</strong>。<br><br>典型的CSS规则包括一个选择器，以及一个或多个属性和值。通过逗号分隔元素名，可以一次选择多个元素。CSS允许你指定各种选择器，来确定将样式应用到哪些元素。比如说：<code>h1,h2 { font-family: sans-serif; color: gray; }</code>，使用font-family属性指定字体。<br><br>一般来说，要把元素的所有共同样式归组在一起，然后把一个元素特定的样式写在另一个规则中。<br><br>下边框与下划线的区别：如果使用border-bottom属性增加下边框，这条线会延伸到页面边缘。而使用属性text-decoration，并使其值为”underline”时给文本增加下划线，下划线只出现在文本的下面。<br></p><h1 id="给多个页面增加同样的样式"><a href="#给多个页面增加同样的样式" class="headerlink" title="给多个页面增加同样的样式"></a>给多个页面增加同样的样式</h1><p>可能首先会想到，将一个样式复制到其它页面中。不过这样太麻烦了，如果样式发生改变，就必须要对每个页面进行修改，这样既浪费时间而且还容易产生错误。<br><br>此时可以对每个页面链接同一个CSS文件，我们通常把CSS文件称为“样式表”(stylesheets)。<strong>可以分两步进行：先写好CSS文件，然后再对各个页面链接该CSS文件。</strong><br>    <ol>        <li>CSS文件的后缀名为css，其内容是将原来`<style>`标记中的内容复制过来，注意不要复制`<style>`和`</style>`标记，因为"xxx.css"文件只包含CSS，不能包含HTML。</li>        <li>然后要从各个页面链接到外部样式表。利用HTML中的`<link>`元素告诉浏览器，它要利用外部样式表为这个页面增加样式。此时不再需要`<style>`元素，要将它删除掉。</li>    </ol><br><code>&lt;link&gt;</code>元素该怎么写？举个例子：<code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;lounge.css&quot;&gt;</code>，使用<code>&lt;link&gt;</code>元素“链入”外部信息。type属性指定类型，这个信息的类型是”text/css”。换句话说，这是一个CSS样式表。在HTML5中，不再需要这个属性（这是可选的），不过在比较老的页面还是会看到它。rel属性指定了HTML文件与所链接的文件之间的关系。我们要链接到一个样式表，所以这里使用值”stylesheet”。样式表放在href中（在这个例子中，我们使用了相对链接，不过这也可以是一个完整的URL）。需要注意的是<code>&lt;link&gt;</code>元素是一个void元素，它没有结束标记。</p><h1 id="继承与覆盖继承"><a href="#继承与覆盖继承" class="headerlink" title="继承与覆盖继承"></a>继承与覆盖继承</h1><p>元素可以从它们的父元素继承样式。但是不是所有样式都能继承。只有一部分能继承，如font-family。<br><br>可能会产生一个疑问，CSS中哪些属性可以继承，哪些属性不能继承？ 一般来讲，如果样式会影响你的文本外观，所有这些样式都能继承，如字体颜色（color属性），font-family（字体系列）以及所有与字体相关的属性，如font-size（字体大小），font-weight（字体粗细）和font-style（是否斜体）。其他属性不能继承，如边框，这是有道理的。比如说，如果<code>&lt;body&gt;</code>元素有一个边框，这并不表示你希望体中的所有元素都有边框。<br>如果没有继承规则的存在，如果对一个段落应用了某种CSS规则，就需要对一个段落中的每一个内联元素增加CSS规则。<br><br>如果要为整个页面设置某种样式，可以利用继承规则对<code>&lt;body&gt;</code>元素设置该样式，从而是整个页面使用该样式。<br><br>如果对某个元素单独指定了某种CSS规则，则这将覆盖它继承得到的CSS规则（覆盖继承的前提是同一属性）。对于CSS，总会使用最特定的那个规则。所以，如果对<code>&lt;body&gt;</code>有一个规则，对<code>&lt;em&gt;</code>元素有一个更特定的规则，它就会使用这个更特定的规则。<br></p><h1 id="为单独的段落指定样式"><a href="#为单独的段落指定样式" class="headerlink" title="为单独的段落指定样式"></a>为单独的段落指定样式</h1><p>这需要引入类(class)的概念。结合HTML和CSS，我们可以定义一类元素，并对属于该类的所有元素应用样式。<br><br>创建一个类有两步：首先，为HTML中的元素增加一个class属性，这样会把元素增加到这个类中；其次，在CSS中选择这个类。<br><br>    <ol>        <li>要将一个元素加入一个类，只需要增加属性"class"，并提供类名。</li>        <li>然后要提供一些规则，为这个类的元素指定样式。</li>    </ol><br>要在CSS中创建一个类，并选择这个类中的一个元素，可以编写一个类选择器，比如说<code>p.greentea { color: green; }</code>，先选择这个类中的元素，在这里就是元素p。再用一个”.”指定一个类。最后是类名。选择器p.greentea会选择greentea类中的所有段落。<br><br>如果希望类中的两个元素使用相同样式，可以使用逗号分隔选择器，比如说：<code>blockquote.greentea, p.greentea { color: green; }</code>。<br><br>如果希望greentea类中的所有元素都有同一种样式，可以这样写规则：<code>.greentea { color: green; }</code>。如果省略所有元素名，只有一个点，后面是类名，那么这个规则会应用到这个类的所有成员。<br><br>并且，元素可以加入多个类。一个元素要加入多个类，比如说指定一个<code>&lt;p&gt;</code>元素属于greentea,raspberry和blueberry类。可以在开始标记中这样写：<code>&lt;p class=&quot;greentea raspberry blueberry&quot;&gt;</code>。即把各个类名放在class属性中，各个类名之间用一个空格分割。类名的顺序并不重要。如果希望一个元素拥有不同类中定义的不同样式，就要使用多个类。<br><br>如果出现多个选择器选择一个元素并且它们都定义了该元素的某种属性的情况，此时一个规则比其他规则更特定，它就会胜出。比如说类比段落特定，类中的特定元素比类特定。不过还有可能这些规则的特定程度是相同的，由于两个选择器有相同的特定性而无法解决冲突，就要利用样式表文件中规则的顺序来解决问题，这些规则中哪个规则在样式表的最后面哪个就会起作用。<br></p><h1 id="CSS验证工具"><a href="#CSS验证工具" class="headerlink" title="CSS验证工具"></a>CSS验证工具</h1><p>如果你的CSS里有错误，通常这个错误以下的所有其它规则都会被忽略。<br><br>CSS的验证工具为<a href="http://jigsaw.w3.org/css-validator/">http://jigsaw.w3.org/css-validator/</a>。</p><h1 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h1><p><ul>    <li>color: 设置文本元素的字体颜色</li>    <li>font-weight: 控制文本的粗细，可用它来设置粗体</li>    <li>left: 指定一个元素的左边所在位置</li>    <li>line-height: 设置一个文本元素的行间距</li>    <li>top: 控制元素顶部的位置</li>    <li>background-color: 控制元素的背景颜色</li>    <li>border: 在一个元素周围加边框。可以有一个实线边框，凸起边框，虚线边框等</li>    <li>padding: 内边距设置，使一个元素边缘和它的内容之间有空间</li>    <li>font-size: 设置文本大小</li>    <li>text-align: 将文本左对齐，居中或右对齐</li>    <li>letter-spacing: 在字母之间设置边距</li>    <li>font-style: 设置斜体文本</li>    <li>list-style: 可用来改变列表中列表项的外观</li>    <li>background-image: 在元素后面放置一个图像</li></ul></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>CSS包含一些简单语句，称为规则。</li><li>每个规则为选择的一些HTML元素提供样式。</li><li>典型的规则包括一个选择器，以及一个或多个属性和值。</li><li>选择器指定规则将应用到哪些元素。</li><li>每个属性声明以一个分号结束。</li><li>规则中的所有属性和值都放在{}大括号之间。</li><li>可以使用元素名作为选择器，来选择任意元素。</li><li>通过逗号分隔元素名，可以一次选择多个元素。</li><li>要在HTML中包含一个样式，最容易的办法就是使用<code>&lt;style&gt;</code>标记。</li><li>对于HTML以及相当复杂的网站，可能要链接到一个外部样式表。</li><li><code>&lt;link&gt;</code>元素用于包含一个外部样式表。</li><li>很多属性都能继承。例如，如果为<code>&lt;body&gt;</code>元素设置了一个可继承的属性，那么<code>&lt;body&gt;</code>的所有子元素都会继承这个属性。</li><li>通过为你想改变的元素创建一个更特定的规则，能覆盖该元素继承的属性。</li><li>可以使用class属性将元素增加到一个类。</li><li>通过在元素名和类名之间加一个”.”，可以选择该类中的一个特定元素。</li><li>使用”.classname”可以选择属于这个类的所有元素。</li><li>通过在class属性中放入多个类名，可以指定一个元素属于多个类，类名之间用空格分割。</li><li>可以使用W3C验证工具验证CSS(<a href="http://jigsaw.w3.org/css-validator/">http://jigsaw.w3.org/css-validator/</a>)。</li></ul></style></li></ol></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(六)</title>
      <link href="/2019/02/26/HTML%E5%92%8CCSS(%E5%85%AD)/"/>
      <url>/2019/02/26/HTML%E5%92%8CCSS(%E5%85%AD)/</url>
      
        <content type="html"><![CDATA[<p>HTML版本说明<br><code>&lt;img&gt;</code>元素的alt属性是必要的<br>字符编码<br>W3C验证工具<br><a id="more"></a><br>明天就可以学CSS啦！</p><h1 id="HTML标准及其他"><a href="#HTML标准及其他" class="headerlink" title="HTML标准及其他"></a>HTML标准及其他</h1><h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><p>为了是浏览器显示正确的HTML，需要告诉浏览器自己在使用哪个版本的HTML，并且要确保自己的页面没有任何错误。（可能有错误发生时在一些浏览器上的显示会与其他浏览器不同）。<br><br>可以用一个doctype告诉浏览器你正在使用的HTML版本，这个“标记”要放在HTML文件的最上面。<br><br>HTML5 doctype为<code>&lt;!doctype html&gt;</code>（这相比较HTML的前几个版本较为简单）。<br><br>可能会疑惑HTML5的doctype中都没有体现出版本5啊？是因为现在的HTML标准已经变成了一个“活的标准”，这意味着它会根据需要继续发展和变化，不过不再有固定的版本号了。也就是说，当浏览器看到：<code>&lt;!doctype html&gt;</code>，它就认为你在使用标准HTML。<br><br>HTML的新的“活标准”的关键是向后兼容性。向后兼容性(backwards compatibility)表示我们可以继续向HTML中增加新的内容，浏览器（最终）会支持这个新内容，不过它们还会继续支持原来的内容。所以，今天写的HTML页面将继续正常工作，甚至以后增加了新的特性之后也仍然能很好地工作。<br></p><h2 id="W3C验证工具"><a href="#W3C验证工具" class="headerlink" title="W3C验证工具"></a>W3C验证工具</h2><p>要得到这个验证工具，只需要将浏览器指向<a href="http://validator.w3.org" target="_blank" rel="noopener">http://validator.w3.org</a>。</p><h2 id="增加一个-lt-meta-gt-指定字符编码"><a href="#增加一个-lt-meta-gt-指定字符编码" class="headerlink" title="增加一个&lt;meta&gt;指定字符编码"></a>增加一个<code>&lt;meta&gt;</code>指定字符编码</h2><p>字符编码为我们提供了一种方法，可以在计算机上表示某种语言中的所有字幕，数字和其它符号。<br><br>如今字符编码的标准已经统一为Unicode字符编码。采用Unicode，一种编码就可以表示所有语言。不过，由于还存在其它编码，所以我们还需要告诉浏览器我们在使用Unicode（或者你选择的另外一种编码）。要为Web页面指定Unicode，需要在HTML中加一个<code>&lt;meta&gt;</code>标记：<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>。”meta”表示我们要告诉浏览器关于页面的一些信息。就像其它HTML标记一样，<code>&lt;meta&gt;</code>标记也有一些属性。要在charset属性中指定字符编码，charset属性值就是我们使用的字符编码类型。”utf-8”是Unicode系列中的一个编码（这个系列还有很多其它编码）。Web页面中使用的就是”utf-8”。<br><br><code>&lt;meta&gt;</code>标记放在<code>&lt;head&gt;</code>元素中（因为<code>&lt;head&gt;</code>包含有关页面的信息），而且还要注意，<code>&lt;meta&gt;</code>标记这一行要增加到<code>&lt;head&gt;</code>元素中所有其他元素的上面。<br></p><h2 id="HTML知识点补充"><a href="#HTML知识点补充" class="headerlink" title="HTML知识点补充"></a>HTML知识点补充</h2><ul><li>只有<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>元素能直接放在<code>&lt;html&gt;</code>元素中。这说明，所有其他元素都必须放在<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>元素中。没有例外！</li><li>一定要在<code>&lt;head&gt;</code>元素中包含一个<code>&lt;title&gt;</code>元素。这是雷打不动的原则。如果没有做到，则会得到不符合标准的HTML。只能在<code>&lt;head&gt;</code>元素中放置<code>&lt;title&gt;</code>，<code>&lt;meta&gt;</code>和<code>&lt;style&gt;</code>元素。</li><li>嵌套某些元素要当心。比如说：不要把<code>&lt;a&gt;</code>元素嵌在另一个<code>&lt;a&gt;</code>元素中，因为这样会让访问者很迷惑。另外，不允许在<code>&lt;img&gt;</code>等void元素中嵌套其他内联元素。</li><li>注意要检查属性！有些元素属性是必要的，有些则是可选的。例如，如果<code>&lt;img&gt;</code>元素没有src属性，就没有什么意义，而且<strong><code>&lt;img&gt;</code>元素的alt属性也是必要的</strong>。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>HTML5是当前的HTML标准。</li><li>万维网协会(World Wide Web Consortium,W3C)是定义HTML标准的标准组织。</li><li>文档类型定义(doctype)用来告诉浏览器你使用的HTML版本。</li><li>HTML标准现在是一个“活的标准”，这说明这个标准会不断改变，加入新的特性和更新。</li><li><code>&lt;head&gt;</code>元素中的<code>&lt;meta&gt;</code>标记告诉浏览器关于一个Web页面的额外信息，如内容类型和字符编码。</li><li><code>&lt;meta&gt;</code>标记的charset属性告诉浏览器Web页面使用的字符编码。</li><li>大多数Web页面的HTML文件都使用utf-8编码，另外<code>&lt;meta&gt;</code>标记的charset属性值通常也是utf-8。</li><li>alt属性是<code>&lt;img&gt;</code>元素中的必要属性。</li><li>W3C验证工具是一个免费的在线服务，可以检查页面是否符合标准。</li><li>可以使用这个验证工具确保你的HTML合法，而且元素和属性符合标准。</li><li>如果遵循标准，则你的页面会更快地显示，而且在不同浏览器中显示时差异会更小，CSS也能更好地工作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(五)</title>
      <link href="/2019/02/24/HTML%E5%92%8CCSS(%E4%BA%94)/"/>
      <url>/2019/02/24/HTML%E5%92%8CCSS(%E4%BA%94)/</url>
      
        <content type="html"><![CDATA[<p>浏览器如何处理图像<br><br>缩略图的使用<br><br><code>&lt;img&gt;</code>元素是一个内联元素，这说明浏览器不会在图像前后插入一个换行<br><br><code>&lt;img&gt;</code>元素的src属性和alt属性介绍<br><br>JPEG,PNG,GIF三种图像格式的特点<br><a id="more"></a><br>开学了嘻嘻，这学期不该提前四天就来的，来了之后好无聊，刚来的第一天还找不到饭吃，真让人难受。下学期开学没啥事的话还是来晚一点吧！</p><h1 id="浏览器如何处理图像"><a href="#浏览器如何处理图像" class="headerlink" title="浏览器如何处理图像"></a>浏览器如何处理图像</h1><p>浏览器处理<code>&lt;img&gt;</code>元素与处理其它HTML元素稍有不同。在读取HTML页面之后，浏览器会从服务器获取各个图像并显示。</p><h1 id="图像格式介绍"><a href="#图像格式介绍" class="headerlink" title="图像格式介绍"></a>图像格式介绍</h1><p>Web上最常用的图像格式是这三种：JPEG,PNG和GIF。<br></p><ul><li>照片和复杂图像使用JPEG<br></li><li>单色图像，logo和几何图像使用PNG或GIF<br><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2>它最适合连续色调图像，如照片。<br><br>可以表示包含多达1600万种不同颜色的图像。<br><br>这是一种“有损”格式，因为缩小文件大小时会丢掉图像的一些信息。<br><br>不支持透明度。<br><br>文件比较小，以便Web页面更高效地显示。<br><br>不支持动画。<br><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2>PNG最适合单色图像和线条构成的图像（如logo,剪贴画和图像中的小文本）。<br><br>PNG可以表示包含上百万种不同颜色的图像。PNG有三种：PNG-8，PNG-24和PNG-32，取决于你需要表示多少种颜色。<br><br>PNG会压缩文件来缩小文件大小，不过不会丢掉信息。所以这是一种“无损”格式。<br><br>允许将颜色设置为“透明”，使图像下面的东西可以显示出来。<br><br>与相应的JPEG文件相比，PNG文件更大一些，不过取决于使用的颜色数，可能比相应的GIF文件小，也可能更大。<h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2>类似于PNG，GIF最适合单色图像和线条构成的图像（如logo,剪贴画和图像中的小文本）。<br><br>GIF可以表示最多256种不同颜色的图像。<br><br>GIF也是一种“无损”格式。<br><br>GIF也支持透明度，不过只允许一种颜色设置为“透明”。<br><br>GIF文件往往比相应的JPEG文件大。<br><br>支持动画。</li><li>在GIF和PNG之间如何选择呢？    要在GIF和PNG中做出选择，有几个方面需要考虑。首先，PNG的压缩要稍稍优于GIF，所以对于一个颜色数相同的图像（也就是说，最多256中颜色），PNG文件可能更小一些。不过，如果需要更多颜色而GIF无法提供，而且也不能选择JPEG（例如，需要透明性），那么就只能选择PNG了。不过，如果需要动画的话，那么还得使用GIF，因为GIF是唯一支持动画并得到广泛支持的格式。<h1 id="lt-img-gt-元素"><a href="#lt-img-gt-元素" class="headerlink" title="&lt;img&gt;元素"></a><code>&lt;img&gt;</code>元素</h1></li><li><code>&lt;img&gt;</code>元素是一个内联元素。它在显示时不会在前面或后面插入换行（浏览器总是在块元素前后在垂直方向上显示间距）。</li><li><code>&lt;img&gt;</code>是一个void元素。</li><li>其src属性指定了在Web页面上显示的图像文件的位置。src属性不只是用于相对链接，还可以在src属性中放入URL。对于相同网站上的图像，最好使用相对路径。对于另一个不同网站上的对象，通常要使用这个图像的URL。需要注意的是，与默认Web页面不同，这里没有默认图像之说。</li><li>void元素就是没有内容和结束标记的元素，为什么说<code>&lt;img&gt;</code>元素是void元素，它不是有内容（图像）吗？    更确切地讲，void元素是指HTML页面中在开始标记和结束标记之间没有任何内容的元素。确实，图像也是内容，不过<code>&lt;img&gt;</code>元素只是指向图像。图像并不是HTML页面本身的一部分。实际上，浏览器显示页面时，图像会取代<code>&lt;img&gt;</code>元素。另外需要记住，HTML页面是纯文本，所以图像无法直接作为页面的一部分。它是单独存在的。</li><li><code>&lt;img&gt;</code>元素的alt属性可以为访问者提供一些暗示，告诉他们图像里有什么信息。alt属性需要指定，描述这个图像的一些文本。如果图像未显示，就会使用这个文本来取代它。</li><li><code>&lt;img&gt;</code>元素还有一对属性:width和height。width属性告诉 浏览器在页面中显示图像的宽度，height属性告诉浏览器在页面显示图像的高度。宽度和高度都使用像素数指定。如果没有指定宽度和高度，则浏览器在页面中显示这个图像之前会自动确定图像的大小。如果在HTML中提供了width和height，浏览器在显示图像之前就可以开始建立页面布局。如果没有指定，则浏览器在知道了图像大小之后，通常需要重新调整页面布局。当然，还可以提供比图像实际尺寸更大或更小的宽度或高度值，这样浏览器就会缩放图像来满足所指定的大小。不过在这种情况下，可能最好考虑使用CSS来得到同样的结果。</li><li>浏览器窗口宽度大约为800像素（计算机显示屏是由数百万个称为像素的点组成的），有时候会面临图像太大，需要用户使用滚动条查看。大多数人通常会把浏览器宽度设置为800到1280像素之间。所以一般经验是将图像最大宽度设置为800像素（通过照片编辑应用将图像调整为合适的大小）。</li><li>为什么不直接使用width属性和height属性来调整页面上图像的大小？因为浏览器在缩放图像使之适应页面大小之前，任然需要获取整个大图像。width属性和height属性实际上是帮助浏览器确定要为这个图像预留多大的空间。如果使用这两个属性，则它们应该与图像的实际宽度和高度一致。<h1 id="使用缩略图"><a href="#使用缩略图" class="headerlink" title="使用缩略图"></a>使用缩略图</h1>在网站的某个页面上，如果有许多照片的话，我们经常看到的是每个照片的一个小的缩略图像，然后可以单击这个缩略图来查看更大的图像，其实现的方法为：<br><ol>  <li>为缩略图创建一个目录。</li>  <li>将照片调整大小，然后保存到第一步所创建的目录下（一般缩略图的名字和原图的名字保持一致）。</li>  <li>将页面中的各个`<img>`元素的src属性设置为照片的缩略版本。</li>  <li>增加从各个缩略图到一个新页面的链接，这个新页面中包含相应的大照片（一般先创建一个包含新页面的文件夹，再创建新页面，再从原页面的缩略图链接到新页面，即用`<a>`元素包围缩略图的`<img>`元素，`<a>`元素的href属性为包含大照片页面的链接）。</a></a></li></ol><br>在用<code>&lt;a&gt;</code>元素包围图像后，鼠标经过图像时，光标会改变，指示你可以单击这个链接图像。大多数情况下,用户都可以通过上下文和鼠标光标了解到一个图像是链接。<br><br>为什么不直接链接到一个大照片而要链接到一个包含大照片的页面？  一般认为直接链接到一个图像并不是一个好的做法，因为通常你需要为所显示的图像提供一些上下文。<h1 id="logo的处理"><a href="#logo的处理" class="headerlink" title="logo的处理"></a>logo的处理</h1>大多数照片编辑应用都会以<strong>背景里的棋盘图案</strong>告诉你这个区域是透明的，为logo选择图形格式时要记住这些。<br><br>如果需要透明背景在设置图片格式时就要选中透明度复选框。用蒙版选项来告诉照片编辑应用使用某种颜色背景在文本周围创建蒙版（默认使用白色背景），即根据背景颜色柔化文本边缘，避免文本周围出现光晕（在Photoshop CS6中蒙版选项为杂边选项）。<br><br>为什么不直接设置logo的背景色为某种颜色，让它与web页面的颜色一致？ 可以这么做，但这有一个缺点：如果Web页面中有其它东西要“透过”logo的透明背景显示出来，倘若logo背景为单色，就无法看到它们了。<br><br>在背景色有很大变化的时候，必须用新的蒙版颜色重新创建PNG。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>如果Web页面上有多个大图像，则可以通过创建图像的缩略图使你的Web页面更可用，下载也更快，缩略图是一些小图像（大图像的缩小版本），用户单击这些缩略图时可以看到原来的大图像。</li><li><code>&lt;img&gt;</code>元素是一个内联元素，这说明浏览器不会在图像前后插入一个换行。</li><li>利用<code>&lt;img&gt;</code>元素的src属性指定图像文件的位置。可以在src属性中使用相对路径包含你自己网站中的图像，或者可以使用URL包含其他网站的图像。</li><li><code>&lt;img&gt;</code>元素的alt属性是对图像的一个有意义的描述。在一些浏览器中，如果无法找到图像，则会显示这个描述，另外屏幕阅读器会使用这个属性为有视力障碍的人描述图像。</li><li>JPEG,PNG和GIF是Web浏览器广泛支持的三种图像格式。JPEG格式最适合保存照片和其它复杂图像。GIF和PNG格式最适合保存logo和其它包含单色，线条或文本的简单图形。</li><li>JPEG图像可以按不同质量压缩，所以可以很好地权衡图像质量和文件大小，来满足你的需要。</li><li>GIF和PNG图像格式允许建立一个有透明背景的图像。如果把一个有透明背景的图像放在一个Web页面中，图像后面的东西（如页面的背景色）就会透过图像的透明部分显示出来。</li><li>GIF和PNG是无损格式，这说明相比于JPEG文件，这些格式的文件往往更大。</li><li>PNG可以提供比GIF更好的透明度控制，而且不像GIF只支持256种颜色，PNG可以支持更多颜色。</li><li>在Photoshop CS6中，使用保存为Web格式对话框中的杂边选项来选择合适的颜色，柔化PNG或GIF图像的边缘。</li><li>图像可以用作指向其它Web页面的链接。要由图像创建一个链接，可以使用<code>&lt;img&gt;</code>元素作为<code>&lt;a&gt;</code>元素的内容，将链接放在<code>&lt;a&gt;</code>元素的href属性中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(四)</title>
      <link href="/2019/01/30/HTML%E5%92%8CCSS(%E5%9B%9B)/"/>
      <url>/2019/01/30/HTML%E5%92%8CCSS(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<p>URL中协议部分告诉浏览器应当使用什么方法来获取资源（大多数情况下，协议都是HTTP）。网站部分（由服务器名和域名组成）告诉浏览器要从互联网上的哪个计算机获取资源。最后绝对路径告诉服务器我们要找哪个页面。<br>使用URL或者相对链接链接到其它页面，结合id属性，然后再加上#可以链接到Web页面的指定位置。<br>还可以在<code>&lt;a&gt;</code>元素中使用title属性对链接进行描述。<br>在<code>&lt;a&gt;</code>元素中使用target属性控制浏览器如何打开一个窗口。<br><a id="more"></a><br>这几天太懒了。</p><h1 id="将Web页面发布到互联网上"><a href="#将Web页面发布到互联网上" class="headerlink" title="将Web页面发布到互联网上"></a>将Web页面发布到互联网上</h1><p>我们需要做这几件事情</p><p><ol>    <li>找一家托管公司。</li>    <li>为你的网站选一个名字（比如www.starbuzzcoffee.com）。</li>    <li>想办法把文件从你的计算机上传到托管公司的服务器上（这样的方法有很多）。</li>    <li>然后就可以把你的新网站告诉别人了！</li></ol></p><h2 id="选择托管公司要考虑以下几点："><a href="#选择托管公司要考虑以下几点：" class="headerlink" title="选择托管公司要考虑以下几点："></a>选择托管公司要考虑以下几点：</h2><p><ul>    <li>技术支持：这家托管公司有没有一个好的系统来处理你的技术问题？比较好的公司会通过电话或邮件对你的问题迅速作出回应。</li>    <li>数据传输：这是托管公司允许你在一定时间内向访问者发送的页面和数据量。大多数托管公司可能会为小网站提供最基本的方案，这些方案中提供的数据传输量并不大。如果你要创建的网站可能有大量访问者，就要仔细考虑这个方面。</li>    <li>备份：这家托管公司是否会定期对你的页面和数据做备份，从而在服务器出现硬件故障时能够恢复？</li>    <li>域名：托管公司定价中是否包含一个域名？</li>    <li>可靠性：大多数托管公司都声称保证网站99%以上的时间内都能正常运行。</li>    <li>赠品：是否附送了其他赠品，比如Email地址，论坛或脚本语言支持？</li></ul></p><h2 id="域名是什么"><a href="#域名是什么" class="headerlink" title="域名是什么?"></a>域名是什么?</h2><p>比如说：对于网站名：<code>www.starbuzzcoffee.com</code>，其中<code>starbuzzcoffee.com</code>部分就是一个域名。不同的域结尾有不同的用途：<code>.com</code>,<code>.org</code>,<code>.gov</code>,<code>.edu</code>。另外还可以表示不同国家：<code>.co.uk</code>,<code>.co.jp</code>等选择一个域时，要选择最适合自己的。<code>www</code>部分是域中一个特定服务器的名字。可以创建使用相同域名的其它网站，也就是说<strong>域名可以用于多个网站</strong>。购买域名就像买下一块地，在这块地上，可以随自己所愿创建很多网站。 </p><h2 id="把自己的文件复制到服务器的根文件夹"><a href="#把自己的文件复制到服务器的根文件夹" class="headerlink" title="把自己的文件复制到服务器的根文件夹"></a>把自己的文件复制到服务器的根文件夹</h2><p>要知道你的根文件夹在服务器的什么位置，然后再把你自己的文件复制到这里。<br><br>需要使用FTP(File Transfer Protocol，文件传输协议)将文件传输到Web。有些FTP应用是命令行的，有些有完备的图形界面，还有一些甚至内置于Dreamweaver和Expression Web之类的应用中。它们都使用相同的命令，不过有些应用要求你自己输入命令，而另外一些允许你使用图形界面。FTP的工作过程如下所示：</p><p></p><p>    <ol>        <li>首先，使用FTP连接到你的服务器。要完成连接，需要托管公司提供的一个用户名和口令。比如说输入`ftp www.starbuzzcoffee.com`请求连接然后连接成功再输入用户名和口令登录。</li>        <li>使用"cd"命令把服务器当前目录切换到文件传输的目标目录。</li>        <li>使用`put`命令将文件上传到服务器。</li>        <li>还可以用`mkdir`命令在服务器上创建一个新目录（也就是新建一个文件夹）。</li>        <li>还可以使用`get`命令获取文件，把一个文件的副本从服务器传回你的计算机。</li>    </ol></p><br>不论我们是在命令行上输入FTP命令，还是使用一个有图形界面的FTP应用，执行的命令或操作基本上都是一样的。常用的FTP命令有：<p></p><p></p><p>    <ul>        <li>dir：得到当前目录的文件列表。</li>        <li>cd：切换到另一个目录。".."也表示上一层目录。</li>        <li>pwd：显示当前目录。</li>        <li>put <filename>：将指定的文件传送到服务器。</filename></li>        <li>get <filename>：从服务器获取指定的文件，传回你的计算机。</filename></li>    </ul></p><br>对于小型的网站，通常需要在自己的计算机上编辑文件，然后每次想要更新网站时都要上传这些文件。在向服务器上传文件之前，可以用自己的计算机测试自己做的修改，确保一切都能正常工作。对于比较大的网站，通常会创建一个测试网站和一个真实网站，这样在转向真实网站之前，可以先在测试网站上预览修改的结果。如果使用的是类似Dreamweaver或Coda等工具，则这些工具允许我们在自己的计算机上测试所做的修改，当我们保存文件时，文件会自动传送到网站。<p></p><h2 id="URL-Uniform-Resource-Locators，统一资源定位符"><a href="#URL-Uniform-Resource-Locators，统一资源定位符" class="headerlink" title="URL(Uniform Resource Locators，统一资源定位符)"></a>URL(Uniform Resource Locators，统一资源定位符)</h2><p>在浏览器中输入的Web地址就是URL，下面来剖析一个URL:<code>http://www.starbuzzcoffee.com/index.html</code>，URL的第一部分<code>http</code>指出了获取资源的协议，第二部分<code>www.starbuzzcoffee.com</code>是网站名，第三部分<code>index.html</code>是从根文件夹到资源的绝对路径。我们用“/”表示根文件夹。<br><br>统一资源定位符是一个全局地址，可以用来定位Web上的任意资源，包括HTML页面，音频，视频和许多其他形式的Web内容。除了指定资源的位置，URL还可以用来指定获取资源的协议。<br><br>还有这种形式的URL:<code>http://www.mydomain.com:8000/index.html</code>，<code>:8000</code>是一个可以放在HTTP URL中的可选的“端口”。可以这样来考虑端口：网站名就像一个地址，端口则像是这个地址的邮箱号（例如，在一个复和公寓里）。通常Web上的所有东西都会传送到一个默认端口（80），不过有时Web服务器会配置为在另外一个不同的端口接收请求（如8000）。这种情况经常在测试服务器上出现。正常的Web服务器几乎都在端口80接收请求。如果你没有指定端口，则默认为80。</p><h2 id="HTTP-HyperText-Transfer-Protocol，超文本传输协议"><a href="#HTTP-HyperText-Transfer-Protocol，超文本传输协议" class="headerlink" title="HTTP(HyperText Transfer Protocol，超文本传输协议)"></a>HTTP(HyperText Transfer Protocol，超文本传输协议)</h2><p>HTTP是在Web上传输超文本文档的公认的一种方法（协议）。尽管“超文本文档”通常只是指HTML页面，但这个协议还可以用来传输图像或Web页面可能需要的任何其他文件。<br>HTTP是一个简单的请求和响应协议。其工作方式如下：<br></p><ul><li>在找得到资源的情况下：<br><img src="images/http1.jpg" alt=""></li><li>如果无法找到资源，则服务器会向浏览器报告我们熟悉的“404错误”：<br><img src="images/http2.jpg" alt=""><br>还有其它的协议！<br><br>浏览器从你的计算机本地读取文件时会使用file协议。如果你想输入一个文件URL，则要注意重要的一点是与HTTP不同，文件URL有3个斜线而不是2个。比如说<code>file:///chapter4/starbuzz/index.html</code>。可以这样来记：如果删去一个HTTP URL中的网站名，那么也会有三个斜线。<h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2>绝对路径总是从根”/“开始，加上导航到文件所经过的每一个文件夹，文件夹名之间加一个”/“来分割，然后再加上文件名。<br><br>在我们以前学<code>&lt;a&gt;</code>元素时其href属性中我们放入的是相对路径。在单击一个相对链接时，在后台浏览器会根据这个相对路径和所单击页面的路径创建一个绝对路径。所以，所有Web服务器看到的都是绝对路径，这要归功于浏览器。<h2 id="默认页面"><a href="#默认页面" class="headerlink" title="默认页面"></a>默认页面</h2>我们还会碰到一种情况：如果浏览器向Web服务器请求一个目录而不是文件时会发生什么？比如说请求服务器根目录中的images目录：<code>http://www.starbuzzcoffee.com/images/</code>。<br><br>Web服务器接收到一个类似这样的请求时，它会尝试查找这个目录中的一个默认文件。通常默认文件名为”index.html”或”default.htm”，如果服务器找到这样一个文件，就会把它返回给浏览器显示。<br><br>所以，要从根目录（或任何其他目录）默认地返回一个文件，只需把这个文件命名为”index.html”或”default.htm”。至于命名为两者当中的哪一个这就需要了解你的托管公司希望你如何命名默认文件，因为这取决于他们使用哪种类型的服务器。<br><br>如果服务器接收到这样一个末尾没有”/“的请求，而且这个目录确实存在，服务器就会帮你加上末尾的斜线。所以如果服务器接收到以下请求：<br><br><code>http://www.starbuzzcoffee.com</code><br><br>它会把这个请求改为<br><br><code>http://www.starbuzzcoffee.com/</code><br><br>这会让服务器查找一个默认文件，最后会返回这个文件，就好像你之前输入了以下地址：<br><br><code>http://www.starbuzzcoffee.com/index.html</code><h1 id="如何链接到其他网站？"><a href="#如何链接到其他网站？" class="headerlink" title="如何链接到其他网站？"></a>如何链接到其他网站？</h1>URL并不只是在浏览器中输入，还可以在HTML中使用。要链接到Web上的资源，只需要它的统一资源定位符(URL)，把这个URL放在<code>&lt;a&gt;</code>元素中作为href属性值。<br><br>链接页面有两种方法：相对路径和URL。相对路径只用来链接同一网站内的页面，而URL通常用来链接其他网站。<h2 id="为链接增加标题以便访问"><a href="#为链接增加标题以便访问" class="headerlink" title="为链接增加标题以便访问"></a>为链接增加标题以便访问</h2><code>&lt;a&gt;</code>元素有一个title属性，就是用来提供链接信息的。需要注意的是，<code>&lt;head&gt;</code>中还有一个名为<code>&lt;title&gt;</code>的元素。之所以名字相同，是因为它们本来就是相关的，通常建议title属性值和所链接的Web页面的<code>&lt;title&gt;</code>元素值相同。不过这不是一个严格的要求，在title属性中提供自己的更具体的描述可能更有意义。<br><br>为<code>&lt;a&gt;</code>增加title属性的例子：  <code>Read the &lt;a href=&quot;http://wickedlysmart.com/buzz&quot; title=&quot;Read all about caffeine on the Buzz&quot;&gt;Caffeine Buzz&lt;/a&gt;</code>，其中title元素有一个值，这是所要链接的页面的文本描述。<br><br>在大多数浏览器中，标题会显示为一个工具提示。当把鼠标移动到链接上，停留一秒，就可以看到这个工具提示。<br><br>可以为任何元素增加title属性，所以如果希望某个元素上有一个工具提示，比如一个标题，则可以在<code>&lt;h1&gt;</code>开始标记中增加一个title属性，就像对<code>&lt;a&gt;</code>一样。有些元素不只是使用title属性作为工具提示，可能还有其他用途，不过工具提示是最常见的用法。<br><br>进一步完善链接时要记住以下技巧：<br><br><ul>  <li>保证链接标签很简洁。不要把整个句子或大段文字放在链接里。一般来讲，要保证只有几个单词。可以在title属性中提供额外的信息。</li>  <li>保证链接标签是有意义的。不要使用类似“单击这里”或“这一页”之类的链接标签（因为这样用户可能只会注意看链接）。</li>  <li>不要把链接放在一起，用户将很难区分放在一起的链接。</li></ul><h2 id="链接到页面中的某个特定位置"><a href="#链接到页面中的某个特定位置" class="headerlink" title="链接到页面中的某个特定位置"></a>链接到页面中的某个特定位置</h2>到现在，我们知道只要链接到另一个页面，浏览器就会加载整个页面，并从头开始显示。<br><br>实际上，<code>&lt;a&gt;</code>元素可以带一个id属性，允许你直接访问页面中的一个特定点。<br><br>需要先使用id属性为<code>&lt;a&gt;</code>创建目标，然后用id链接到元素。<br><br>可以为任意元素增加id属性，也就是说可以为一个<code>&lt;a&gt;</code>元素增加id属性，即链接到一个链接。<br><h3 id="使用id属性为-lt-a-gt-创建目标"><a href="#使用id属性为-lt-a-gt-创建目标" class="headerlink" title="使用id属性为&lt;a&gt;创建目标"></a>使用id属性为<code>&lt;a&gt;</code>创建目标</h3>id一定要用一个字母开头(A~Z或a~z)，后面可以是任意字母，数字，横线，下划线，冒号或点号。<br><br>可以认为id属性是一种唯一标志元素的方法。带id的元素有一个特殊特性：你可以直接链接这些元素。使用id属性在页面中为<code>&lt;a&gt;</code>创建目标的步骤为：<br><br><ol>  <li>找到页面中你希望创建锚点的位置。这可以是页面上的任何文本，不过通常是标题。</li>  <li>为目标选择一个标识符名，如"coffee"或"summary"或"bio"，并在元素的开始标记中插入一个id属性。需要注意，id必须是这个页面中唯一的。</li></ol><h3 id="如何用id链接到元素"><a href="#如何用id链接到元素" class="headerlink" title="如何用id链接到元素"></a>如何用id链接到元素</h3>不论是相对链接还是URL，要链接到页面中的一个特定目标，只需要在链接最后加一个#，再加上目标标识符。<br><br>特定目标的主要好处是链接到长文件中的某个位置，使得访问者不必向下滚动文件来查找所需的部分。<br><br>比如说链接到index.html的Coffee处： <code>Read the &lt;a href=&quot;http://wickedlysmart.com/buzz/index.html#Coffee&quot; title=&quot;Read all about caffeine on the Buzz&quot;&gt;Caffeine Buzz&lt;/a&gt;</code><br><br>可以在文档中放置一个指向相同文档中某个目标的链接。例如，要链接到同一个页面上的”top”目标，可以写为<code>&lt;a href=&quot;#top&quot;&gt;Back to top&lt;/a&gt;</code>。<br><br>不一定总使用文字作为<code>&lt;a&gt;</code>元素的内容。<code>&lt;a&gt;</code>元素能够由文字和图像（内联内容）创建链接，在HTML5中进一步更新，现在还可以从块元素（如<code>&lt;p&gt;</code>和<code>&lt;blockquote&gt;</code>）创建链接！所以可以用<code>&lt;a&gt;</code>有各种不同内容创建链接。<br><h2 id="使用target打开新窗口"><a href="#使用target打开新窗口" class="headerlink" title="使用target打开新窗口"></a>使用target打开新窗口</h2>要在一个新窗口中打开一个页面，需要告诉浏览器你要打开的窗口名。如果没有告诉浏览器要使用哪个特定的窗口，浏览器就会在同一个窗口中打开这个页面。可以为<code>&lt;a&gt;</code>元素增加一个target属性，告诉浏览器使用一个不同的窗口。target属性值会告诉浏览器页面的”目标窗口“。如果使用<code>_blank</code>作为目标，浏览器就总是打开一个新窗口显示页面。<br><br>举个例子：<code>&lt;a target=&quot;_blank&quot; href=&quot;http://wickedlysmart.com/buzz&quot; title=&quot;Read all about caffeine on the Buzz&quot;&gt;Caffeine Buzz&lt;/a&gt;</code>，其中target属性告诉浏览器在哪里打开href属性中链接指示的Web页面。如果没有target，浏览器就会在同一个窗口中打开这个链接。如果目标为<code>_blank</code>，浏览器就会在一个新窗口中打开链接。<br><br>现在大多数浏览器都有一个默认设置，会在一个标签页中打开新窗口，而不是一个全新的浏览器窗口。不过新的标签页和新窗口实际上是一样的，只是标签页可以共享原窗口的窗口边框。如果想强制打开一个全新的窗口，则大多数浏览器上可以通过首选项设置来实现。<br><br>如果所有<code>&lt;a&gt;</code>元素中的target都指定为”_blank”，那么每个链接都会在一个新的空窗口打开。不过不一定要把target指定为<code>_blank</code>。如果指定另一个名字，如”coffee”，那么有相同目标名”coffee”的所有链接都会在同一个窗口中打开。这是因为，为target指定一个特定的名字时，如”coffee”，实际上就是在对显示链接页面的新窗口命名。<code>_blank</code>则是一种特殊情况，告诉浏览器总是使用一个新窗口。<br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>托管公司可能会为你的域创建一个或多个Web服务器。服务器通常命名为”www”。</li><li>典型的URL由一个协议，一个网站名和资源的一个绝对地址组成。</li><li>浏览器使用file协议从你的计算机读取页面。</li><li>“index.html”和”default.htm”都是默认页面。如果指定一个目录而没有指定文件名，则Web服务器会查找一个默认页面返回到浏览器。</li><li>可以用id属性在页面中创建一个目标。使用#后面增加一个目标id，可以链接到页面中的那个位置。</li><li>为了便于访问，可以在<code>&lt;a&gt;</code>元素中使用title属性提供链接的一个描述。</li><li>使用target属性在另一个浏览器窗口中打开链接。不过对于使用各种不用设备和浏览器的用户，target属性可能会有问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(三)</title>
      <link href="/2019/01/22/HTML%E5%92%8CCSS(%E4%B8%89)/"/>
      <url>/2019/01/22/HTML%E5%92%8CCSS(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<p>引用元素<code>&lt;q&gt;</code>和引用元素<code>&lt;blockquote&gt;</code>的区别：<code>&lt;q&gt;</code>是内联元素，适合于小段引用时使用，而<code>&lt;blockquote&gt;</code>是块元素，适合于大段引用。<br>一个列表由两种元素构成：列表类型和列表项。列表类型有无序列表（<code>&lt;ul&gt;</code>元素表示）以及有序列表（<code>&lt;ol&gt;</code>元素表示），列表项由<code>&lt;li&gt;</code>元素表示。这三个元素都是块元素。<br><a id="more"></a><br>再次意识到自己很菜qaq</p><h1 id="认识-lt-q-gt-元素"><a href="#认识-lt-q-gt-元素" class="headerlink" title="认识&lt;q&gt;元素"></a>认识<code>&lt;q&gt;</code>元素</h1><ul><li><code>&lt;q&gt;</code>元素用来在HTML里面添加简短的引用。下面是一小段测试HTML:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Quote Test Drive&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">You never know when you&apos;ll need a good quote, how about &lt;q&gt;To be or not to be&lt;/q&gt;, or &lt;q&gt;Wherever you go, there you are&lt;/q&gt;.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>每个引用都要用一个<code>&lt;q&gt;</code>开始标记和一个<code>&lt;/q&gt;</code>结束标记包围。注意，这里没有在引用周围加双引号。这些引用在浏览器中会如下图这样显示，浏览器会负责加上双引号。<br><img src="images/testq.jpg" alt=""></li><li><strong>并不是所有浏览器都会在<code>&lt;q&gt;</code>元素的内容两边加双引号</strong>。</li><li>使用<code>&lt;q&gt;</code>元素可以使页面更结构化，更有意义。人们在文本中使用双引号原因可能有很多（使用双引号并不代表它确实是引用文字），但是如果使用的是<code>&lt;q&gt;</code>元素，这就意味着这是某种特定的内容，它表示的是一段引用文字。也就是说，通过标记引用，我们可以为它增加更多的含义（并且我们可以对引用设置样式，使它的外观如我们所愿）。<h1 id="很长的引用"><a href="#很长的引用" class="headerlink" title="很长的引用"></a>很长的引用</h1></li><li><code>&lt;q&gt;</code>用于短引用，作为现有段落的一部分。<code>&lt;blockquote&gt;</code>元素用于较长的引用，需要单独显示。</li><li>一个使用<code>&lt;blockquote&gt;</code>的例子如下所示（节选的一部分代码）：</li></ul><pre><code>&lt;h2&gt;July 14, 2012&lt;/h2&gt;&lt;p&gt;  I saw some Burma Shave style signs on the side of the  road today:&lt;/p&gt;&lt;blockquote&gt;  Passing cars,   When you can&#39;t see,   May get you,   A glimpse,   Of eternity. &lt;/blockquote&gt;&lt;p&gt;  I definitely won&#39;t be passing any cars.&lt;/p&gt;</code></pre><p>我们在浏览器中打开后如下所示：<br><img src="images/html3_2.jpg" alt=""></p><ul><li>可以看出<code>&lt;blockquote&gt;</code>创建了一个单独的文本块（与<code>&lt;p&gt;</code>类似），另外还把文字稍微缩进，使它更像一个引用。不过我们的引用与原先预想的还有差距，因为所有行都在一起。我们希望它分行显示。</li><li>如果想引用一段或者多段文字，就要使用<code>&lt;blockquote&gt;</code>，不过如果只想把一个引用放在现有的文字里，作为其中的一部分，就可以使用<code>&lt;q&gt;</code>。</li><li>把段落元素放在<code>&lt;blockquote&gt;</code>中，一个段落元素对应一个段落就可以实现一个块引用中有多段。</li><li><strong>只是有些浏览器显示<code>&lt;blockquote&gt;</code>时会缩进。一些浏览器对于<code>&lt;blockquote&gt;</code>可能不使用缩进。</strong>所以，不要指望<code>&lt;blockquote&gt;</code>在所有浏览器中都有相同的显示。</li><li>引用元素可以结合使用，可以将一个<code>&lt;q&gt;</code>元素放在<code>&lt;p&gt;</code>元素中，同样的，也可以将<code>&lt;q&gt;</code>嵌在<code>&lt;blockquote&gt;</code>中。如果引用某个人的话，而他又引用另外某个人的言论，可能就需要这样的嵌套使用。不过把<code>&lt;blockquote&gt;</code>放在一个<code>&lt;q&gt;</code>元素中似乎没有任何意义。</li><li><code>&lt;blockquote&gt;</code>和<code>&lt;q&gt;</code>实际是两类不同的元素。<code>&lt;blockquote&gt;</code>元素是一个块(block)元素，而<code>&lt;q&gt;</code>元素是一个内联(inline)元素。块元素显示时就好像前后各有一个换行，而内联元素在页面文本流中总在“行内”出现。</li><li>块元素特立独行，内联元素随波逐流。<code>&lt;h1&gt;,&lt;h2&gt;,...&lt;h6&gt;,&lt;p&gt;</code>和<code>&lt;blockquote&gt;</code>都是块元素，每个块元素都单独显示，就好像前后都有换行。块元素的内容分块显示。<code>&lt;q&gt;,&lt;a&gt;</code>和<code>&lt;em&gt;</code>是内联元素。<code>&lt;q&gt;</code>则不同，与所有元素一样，<code>&lt;q&gt;</code>会显示在所在的段落中。</li><li>块元素通常用作Web页面中的主要构建模块，而内联元素往往用来标记小段内容。设计一个页面时，一般先从较大的块开始（块元素），然后在完善页面时再加入内联元素。</li><li>为什么在上面的图片中引用的文字不能分行显示呢？浏览器不会显示空白符和换行！！！可以考虑把每一行都放在一个块元素中。但是实际上HTML中提供了元素进行换行操作——<code>&lt;br&gt;</code>元素！在希望换行的地方增加一个<code>&lt;br&gt;</code>元素，这里就会插入一个“换行符”。</li><li><code>&lt;br&gt;</code>元素是一个没有任何内容的元素，因为它只是一个换行，没有其他内容。对于一个没有实际内容的元素，我们会使用简写来表示这个元素，最后就会像<code>&lt;br&gt;</code>一样。<code>&lt;br&gt;</code>并不是唯一没有实际内容的元素，还有很多类似这样的元素，我们把这些元素叫做void元素（也叫作空元素）。比如说我们之前见到过的<code>&lt;img&gt;</code>元素。<h1 id="两步轻松构建HTML列表"><a href="#两步轻松构建HTML列表" class="headerlink" title="两步轻松构建HTML列表"></a>两步轻松构建HTML列表</h1></li><li>创建一个HTML列表需要两个元素，结合使用这两个元素构成了列表。第一个元素用来标记每个列表项——<code>&lt;li&gt;</code>元素(list item)。第二个元素确定你创建的是哪种类型的列表：有序列表（ordered list，用<code>&lt;ol&gt;</code>元素表示）还是无序列表（unordered list，用<code>&lt;ul&gt;</code>元素表示）。</li><li><strong>第一步：将每个列表项放在一个<code>&lt;li&gt;</code>元素中。</strong>要创建一个列表，需要把每个列表项放在单独的<code>&lt;li&gt;</code>元素中，这说明需要把内容用一个开始<code>&lt;li&gt;</code>标记和一个结束<code>&lt;/li&gt;</code>标记包围起来。与所有其它HTML元素一样，标记之间的内容由自己来确定，可以很短，也可以很长，分为多行。</li><li><strong>第二步：用<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>元素包围列表项。</strong>如果使用一个<code>&lt;ol&gt;</code>元素包围列表项，则这些列表项将作为一个有序列表显示，浏览器将会负责对每个列表项进行编号；如果使用<code>&lt;ul&gt;</code>，则列表项将显示为一个无序列表。</li><li><code>&lt;li&gt;</code>和<code>&lt;ol&gt;</code>以及<code>&lt;ul&gt;</code>元素都是块元素。</li><li>可以把一个<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>作为某个<code>&lt;li&gt;</code>的内容，这样就在列表中有了另一个列表（我们把这叫做嵌套列表）。</li><li>HTML中有有序列表和无序列表，还有另外一类列表：定义列表（用<code>&lt;dl&gt;</code>元素表示），列表中每一项都有一个定义术语<code>&lt;dt&gt;</code>和一个定义描述<code>&lt;dd&gt;</code>。<h1 id="HTML内容中特殊字符的表示方法"><a href="#HTML内容中特殊字符的表示方法" class="headerlink" title="HTML内容中特殊字符的表示方法"></a>HTML内容中特殊字符的表示方法</h1></li><li>因为浏览器要使用<code>&lt;</code>和<code>&gt;</code>来开始和结束标记，如果在HTML内容中使用这两个字符，就会有问题。不过HTML提供了一种简便的方法，可以使用一种称为字符实体(character entity)的简单缩写来指定这样一些特殊字符。它是这样工作的：对于被认为特殊的字符，或者你可能希望在Web页面中使用某个字符但在你的编辑器里无法输入(比如版权符号)，就可以查找相应的缩写在HTML中直接输入。例如，<code>&gt;</code>字符的缩写是<code>&amp;gt;</code>,<code>&lt;</code>字符的缩写是<code>&amp;lt;</code>。</li><li>加入下网在页面中输入<code>&quot;The &lt;html&gt; element rocks.&quot;</code>。通过使用字符实体，可以这样输入：<code>The &amp;lt;html&amp;gt; element rocks.</code>。还有一个特殊的字符是<code>&amp;</code>字符(与字符)。如果希望HTML内容中出现一个<code>&amp;</code>，则可以使用字符实体<code>&amp;amp;</code>，而不要直接使用字符<code>&amp;</code>。<code>&amp;</code>字符之所以特殊是因为它是所有实体的第一个字符。所以在实体名中使用<code>&amp;</code>是完全可以的，但不能单独使用<code>&amp;</code>。只要记住，输入实体时都会用到<code>&amp;</code>，而如果内容中确实需要一个<code>&amp;</code>，就要使用<code>&amp;amp;</code>。另外版权符号的表示为<code>&amp;copyright;</code>。</li><li><code>www.unicode.org</code>网站上有太多的不同字符和语言。只有当所用的计算机或设备安装了正确的字体时，浏览器才可能显示所有这些字符。</li><li>在<code>www.w3schools.com</code>上查看了字符实体，并且每个实体还有一个编号。可以在HTML中使用这个编号，比如<code>&amp;#100</code>，也可以使用实体名，它们的作用都是一样的。不过，并不是所有的实体都有名字，所以如果没有实体名，所以如果没有实体名，那么使用这个编号就是唯一选择了。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li><code>&lt;code&gt;</code>元素用来显示计算机程序代码。<code>&lt;em&gt;</code>元素来标记想用不同方式展示的文本，比如想强调一个重点。<code>&lt;time&gt;</code>元素用来告诉浏览器这个内容是一个日期或时间，或者同时包含日期和时间。<code>&lt;strong&gt;</code>元素来标记希望特别强调的文本。<code>&lt;pre&gt;</code>希望浏览器按照我们自己输入的方式原样显示文本时，使用这个元素来指定文本格式。</li><li>开始输入内容之前要规划好Web页面的结构，然后画出一个草图，然后创建一个略图，最后在写出HTML。要尽可能使用元素来告诉浏览器我们的内容的含义。一定要使用与内容含义最接近的元素。例如，如果创建一个列表，就不要使用段落元素。</li><li>块元素在内容前后分别有一个换行。</li><li>要插入自己的换行时，可以使用<code>&lt;br&gt;</code>元素，它是一个”void”元素。</li><li>void元素没有内容。并且只有一个标记组成。</li><li>“空”元素没有内容，不过它由开始和结束标记。</li><li>要对HTML中的特殊字符使用字符实体。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(二)</title>
      <link href="/2019/01/20/HTML%E5%92%8CCSS(%E4%BA%8C)/"/>
      <url>/2019/01/20/HTML%E5%92%8CCSS(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>使用<code>&lt;a&gt;</code>元素创建一个超文本链接，链接到另一个Web页面。<code>&lt;a&gt;</code>元素的内容会成为Web页面中可单击的文本。href属性告诉浏览器链接的目标文件。<br><a id="more"></a><br>嘻嘻，考完试回家了，终于可以尽情放飞自我了！！！开心.jpg</p><ul><li>在（一）中我们提到HTML，它是一种标记语言（HTML中的“ML”），用来描述网页的结构。而HTML中的“HT”，也就是超文本（hypertext），它可以使我们摆脱单个页面的束缚，链接到其它页面。<h1 id="如何创建一个浏览器链接？"><a href="#如何创建一个浏览器链接？" class="headerlink" title="如何创建一个浏览器链接？"></a>如何创建一个浏览器链接？</h1></li><li>在创建HTML链接时，首先需要把链接文本放在<code>&lt;a&gt;</code>元素中。<br>for example:<code>&lt;a&gt;elixirs&lt;/a&gt;</code>，<code>&lt;a&gt;driving directions&lt;/a&gt;</code>，<code>&lt;a&gt;</code>元素用于创建指向另一个页面的链接，<code>&lt;a&gt;</code>元素的内容就是链接文本。在浏览器中，链接文本会显示有下划线，指示这是可以单击的。</li><li>有了链接文本后还得增加一些HTML告诉浏览器这个链接指向哪里，要通过href属性来指定链接的目标文件。<br>for example:<code>&lt;a href=&quot;elixir.html&quot;&gt;elixirs&lt;/a&gt;</code>，对于这个链接，浏览器会显示文本”elixirs”，单击这个文本时，用户将被带往”elixir.html”页面。<br><code>&lt;a href=&quot;directions.html&quot;&gt;driving directions&lt;/a&gt;</code>，对于这个链接，浏览器会显示”driving directions”链接，单击时，用户会进入”directions.html”页面。<h1 id="浏览器做了什么？"><a href="#浏览器做了什么？" class="headerlink" title="浏览器做了什么？"></a>浏览器做了什么？</h1></li><li>首先，浏览器会显示页面，如果遇到一个<code>&lt;a&gt;</code>元素，则会取这个元素的内容，把它显示为一个可单击的链接。</li><li>接下来，用户单击一个链接时，浏览器使用”href”属性来确定这个链接指向哪个页面。<h1 id="了解属性"><a href="#了解属性" class="headerlink" title="了解属性"></a>了解属性</h1></li><li>利用属性(Attributes)，可以指定一个元素的附加信息。<br>for example:<br>  <code>&lt;style type=&quot;text/css&quot;&gt;</code>，type属性指定我们使用哪一种样式语言，这里就是css。<br>  <code>&lt;a href=&quot;irule.html&quot;&gt;</code>，href属性告诉我们一个超链接的目标文件。<br>  <code>&lt;img src=&quot;sweetphoto.gif&quot;&gt;</code>，src属性指定一个img标记显示的图像的文件名。</li><li>有了属性，就可以用各种信息定制这个元素。属性的写法都是一样的：首先是属性名，后面是一个等于号，然后是用双引号括起来的属性值（可能Web上有一些不严谨的HTML没有加双引号，不过不建议这么做，这可能会导致遇到一些问题）。</li><li>href的含义是“超文本引用”(hypertextreference)，超文本引用是互联网或计算机上的一个资源的别称。通常这个资源就是一个Web页面，不过也可以指向PDF文档……实际上可以指向各种各样的资源。</li><li>如果把一个<code>&lt;img&gt;</code>元素放在<code>&lt;a&gt;</code>标记之间，这个图像就会像文本一样可单击，即图像也可以作为链接。同样也可以将一个段落，即把一个<code>&lt;p&gt;</code>元素放在<code>&lt;a&gt;</code>元素中来链接整个段落。但是我们大多会在<code>&lt;a&gt;</code>元素中使用文本和图像。<code>&lt;h1&gt;</code>元素也可以放在<code>&lt;a&gt;</code>元素之间。<h1 id="组织文件夹"><a href="#组织文件夹" class="headerlink" title="组织文件夹"></a>组织文件夹</h1></li><li>注意网页文件的结构，一般会将图片单独放在根目录下的一个文件夹中，这样方便所有的网页都可以使用该文件夹下的图片。当然也可以将图片文件夹放在根目录的子文件夹下面。</li><li>告诉浏览器上行的方法是使用<code>&quot;..&quot;</code>，而如果需要向上两级文件夹的话，可以使用<code>&quot;../..&quot;</code>，也就是说每一次使用<code>&quot;..&quot;</code>，就会向上到上一层父文件夹。所以要想向上两级文件夹的话，就使用两次<code>&quot;..&quot;</code>，仍然要用<code>&quot;/&quot;</code>分割每一部分。</li><li>还需要注意的是，对于网页，只能使用<code>&quot;/&quot;</code>(斜线)作为分隔符。不要使用<code>&quot;\&quot;</code>(反斜线)。不同的操作系统使用不同的文件分割符（例如，Windows使用<code>&quot;\&quot;</code>而不是<code>&quot;/&quot;</code>），但是在Web上，我们使用一个通用的分隔符，所有操作系统都要使用这个分隔符，也就是在HTML的路径中都要使用<code>&quot;/&quot;</code>。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>想从一个页面链接到另一个页面，要使用<code>&lt;a&gt;</code>元素。<code>&lt;a&gt;</code>元素的href属性指定了链接的目标文件。<code>&lt;a&gt;</code>元素的内容是链接的标签。这个标签就是在网页上看到的链接文本。默认地，这个标签会有下划线，指示这是可以单击的。文字或图像都可以都可以用作链接的标签。单击一个链接时，浏览器会加载href属性中指定的Web页面。可以链接到相同文件夹中的文件，也可以链接到其它文件夹中的文件。</li><li>相对路径是相对于链接的源Web页面指向网站中其他文件的一个链接。就像在地图上一样，终点总是相对于起点。使用<code>&quot;..&quot;</code>可以链接到源文件上一层文件夹中的一个文件。<code>&quot;..&quot;</code>表示的是“父文件夹”。要用<code>&quot;/&quot;</code>(斜线)字符分割路径中的各个部分。</li><li>指向一个图像的路径不正确时，会在Web页面上看到一个损坏的图像。为网站选择的文件名和文件夹名中不要使用空格。</li><li>最好在构建网站初期组织网站文件，这样就不用在网站升级时修改一大堆的路径了。组织网站有很多方法，具体如何组织由自己决定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML和CSS(一)</title>
      <link href="/2018/12/09/HTML%E5%92%8CCSS(%E4%B8%80)/"/>
      <url>/2018/12/09/HTML%E5%92%8CCSS(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>对HTML和CSS初步了解，二者是完全不同的语言，HTML决定了网页的结构，CSS决定了网页的样式。二者共同决定了网页的表现。<br><a id="more"></a></p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li>HTML(HyperText Markup Language)即超文本标记语言，可以用该语言来编写文件建立Web页面，将这些Web页面放在Web服务器上，连接到互联网的PC和其它设备就可以用浏览器来得到此页面。根据Web页面的HTML，浏览器可以知道显示页面所需的全部信息。可以说HTML是浏览器显示页面的关键。</li><li>第一个HTML文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Starbuzz Coffee&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Starbuzz Coffee Beverages&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;House Blend, $1.49&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A smooth, mild blend of coffees from Mexico, Bolivia</span><br><span class="line">       and Guatemals.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Mocha Cafe Latte, $2.35&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;Espresso, steamed milk and chocolate syrup.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Cappuccino, $1.89&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A mixture of espresso, steamed milk and foam.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Chai Tea, $1.85&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A spicy drink made with black tea, spices, milk and </span><br><span class="line">       honey.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>要告诉浏览器页面的结构，就需要用成对的标记包围页面的内容。<br>需要注意的是 元素 = 开始标记 + 内容 + 结束标记，举个例子：<br>    <code>&lt;h1&gt;Starbuzz Coffee Beverages&lt;/h1&gt;</code><br>就是一个<code>&lt;h1&gt;</code>元素。</p><ul><li>HTML提供了一种方法来描述文件中内容的结构。浏览器在显示HTML时，它会使用它自己的内置的默认样式来表示这个结构。不过这远远不能满足我们的需求，于是就产生了CSS。<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1></li><li>CSS(Cascading Style Sheets)即层叠样式表，它提供一种方法来告诉浏览器页面中的元素该如何显示。</li><li>style元素。<code>&lt;style&gt;</code>元素放在HTML的首部里，与其它元素类似，<code>&lt;style&gt;</code>元素有一个开始标记<code>&lt;style&gt;</code>，还有一个结束标记<code>&lt;/style&gt;</code>。且该标记还有一个可选的属性（属性用来提供一个元素的附加信息），名为type，它告诉浏览器我们在使用什么类型的样式，由于我们使用的是CSS,所以可以指定”text/css”类型。</li><li>对上面的页面加一些样式，新的代码如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Starbuzz Coffee&lt;/title&gt;</span><br><span class="line">&lt;style type = &quot;text/css&quot;&gt;</span><br><span class="line">body &#123;</span><br><span class="line">background-color: #d2b48c;        &lt;!-- 设置背景色为土黄色，这是用十六进制码指定一个颜色 --&gt;</span><br><span class="line">margin-left: 20%;</span><br><span class="line">margin-right: 20%;                        &lt;!-- 设置左右外边距分别占页面的20% --&gt;</span><br><span class="line">border: 2px dotted black;             &lt;!-- 定义页面主体周围的边框是虚线，颜色为黑色 --&gt;</span><br><span class="line">padding: 10px 10px 10px 10px;    &lt;!-- 在页面主体周围创建一些内边距 --&gt;</span><br><span class="line">font-family: sans-serif;                   &lt;!-- 定义文本使用的字体 --&gt;</span><br><span class="line">&#125;    &lt;!-- &lt;body&gt;元素表示花括号之间的所有CSS都要应用于HTML --&gt; </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Starbuzz Coffee Beverages&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;House Blend, $1.49&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A smooth, mild blend of coffees from Mexico, Bolivia</span><br><span class="line">       and Guatemals.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Mocha Cafe Latte, $2.35&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;Espresso, steamed milk and chocolate syrup.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Cappuccino, $1.89&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A mixture of espresso, steamed milk and foam.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Chai Tea, $1.85&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;A spicy drink made with black tea, spices, milk and </span><br><span class="line">       honey.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>不过虽然自己用的是谷歌浏览器但是也没有显示边框。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>HTML和CSS是我们用来创建网页的语言。</li><li>Web服务器存储并提供由HTML和CSS创建的网页。浏览器获取页面，并根据HTML和CSS显示网页的内容。</li><li>HTML用来建立网页的结构，CSS用来控制HTML的表现。</li><li>所有页面都有一个<code>&lt;HTML&gt;</code>元素，其中还要有一个<code>&lt;head&gt;</code>元素和一个<code>&lt;body&gt;</code>元素，网页的信息放在<code>&lt;head&gt;</code>元素里，<code>&lt;body&gt;</code>元素里的内容就是将在浏览器里看到的东西。</li><li>通过HTML，我们利用标记来标志内容提供结构。我们把匹配标记以及它们包围的内容称为元素，也就是说元素是由三部分构成的：开始标记 + 内容 + 结束标记，不过需要注意的是有些元素(比如<code>&lt;img&gt;</code>)有所例外。</li><li>开始标记可以有属性，比如说我们例子中的type。</li><li>可以在<code>&lt;style&gt;</code>元素中写CSS规则，为HTML网页增加CSS。<code>&lt;style&gt;</code>元素总要放在<code>&lt;head&gt;</code>元素里。</li><li>可用CSS在HTML中指定元素的特性。<br>快要期末考试了，还有大作业没有写qaq，而且似乎最近的状态不怎么好，不过还是要加油呀！ </li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LCS和LIS</title>
      <link href="/2018/08/12/LCS%E5%92%8CLIS/"/>
      <url>/2018/08/12/LCS%E5%92%8CLIS/</url>
      
        <content type="html"><![CDATA[<p>求解最长公共子序列与最长上升子序列问题以及如何利用最长公共子序列的求解方法来求解最长上升子序列。<br><a id="more"></a></p><h1 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h1><ul><li>LCS即<strong>最长公共子序列</strong>（Longest Common Subsequence）。</li><li><p>对于dp数组可以采用如下的定义:</p><p>   dp[i][j] :=s<sub>1</sub>…s<sub>i</sub>和t<sub>1</sub>…t<sub>j</sub>对应的LCS的长度</p></li><li><p>由此，s<sub>1</sub>…s<sub>i+1</sub>和t<sub>1</sub>…t<sub>j+1</sub>对应的最长公共子序列应该是</p><p>   1.当s<sub>i+1</sub>=t<sub>j+1</sub>时，在s<sub>1</sub>…s<sub>i</sub>和t<sub>1</sub>…t<sub>j</sub>的最长公共子序列末尾追加上s<sub>i+1</sub>.</p><p>   2.否则应该为s<sub>1</sub>…s<sub>i</sub>和t<sub>1</sub>…t<sub>j+1</sub>的最长公共子序列和s<sub>1</sub>…s<sub>i+1</sub>和t<sub>1</sub>…t<sub>j</sub>的最长公共子序列中最长的那个。</p></li><li>根据上述描述可求得dp数组的递推关系，关系可见代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int n , m;</span><br><span class="line">char s[MAX_N], t[MAX_M];</span><br><span class="line"></span><br><span class="line">int dp[MAX_N+1][MAX_M+1];    //DP数组</span><br><span class="line"></span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i] == t[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i+1][j+1] = dp[i][j] + 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, dp[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时的时间复杂度为O(nm)。</li></ul><h1 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h1><ul><li>LIS即<strong>最长上升子序列</strong>(Longest Increasing Subsequence)。</li><li>对于这种问题的求解通常有三种做法。<h2 id="1-动态规划-时间复杂度为O-n2"><a href="#1-动态规划-时间复杂度为O-n2" class="headerlink" title="1.动态规划(时间复杂度为O(n2))"></a>1.动态规划(时间复杂度为O(n<sup>2</sup>))</h2></li><li><p>定义dp[i]:=以a<sub>i</sub>为末尾的最长上升子序列的长度</p><p>  以a<sub>i</sub>结尾的上升子序列可以是:</p><p>   1.只包含a<sub>i</sub>的子序列</p><p>   2.在满足j &lt; i并且a<sub>j</sub> &lt; a<sub>i</sub>的以a<sub>j</sub>为结尾的上升子列末尾，追加上a<sub>i</sub>后得到的子序列</p></li><li>根据上述描述可求得dp数组的递推关系，关系可见代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int n,;</span><br><span class="line">int a[MAX_N];</span><br><span class="line"></span><br><span class="line">int dp[MAX_N];    //DP数组</span><br><span class="line"></span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">int res = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">for(int j = 0; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i] = max(dp[j]+1, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-动态规划-二分查找-时间复杂度为O-nlogn"><a href="#2-动态规划-二分查找-时间复杂度为O-nlogn" class="headerlink" title="2.动态规划+二分查找(时间复杂度为O(nlogn))"></a>2.动态规划+二分查找(时间复杂度为O(nlogn))</h2><ul><li><p>可以看这么一个例子：假设存在一个序列d[1..9] = 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5。<br>下面一步一步试着找出它。<br>我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。<br>此外，我们用一个变量Len来记录现在最长算到多少了</p><p>  首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p><p>  然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，这时Len=1</p><p>  接着，d[3] = 5，d[3]&gt;B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，这时候B[1..2] = 1, 5，Len＝2</p><p>  再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2</p><p>  继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6， Len = 3 了哦。</p><p>  第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3</p><p>  第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了</p><p>  第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。</p><p>  最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。</p><p>  于是我们知道了LIS的长度为5。</p><p>  !!!!! 注意。这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。</p><p>  然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)<del>~</del>于是算法的时间复杂度就降低到了O(NlogN)～！</p></li><li>根据上面的例子我们可以体会到如果子序列的长度相同，那么最末尾的元素较小的在之后会更加有优势。</li><li><p>因此我们定义dp[i]:=长度为i+1的上升子序列中末尾元素的最小值(不存在的话就是INF)，最开始全部dp[i]的值都初始化为INF。然后由前到后逐个考虑数组的元素，对于每一个a<sub>j</sub>，如果i=0或者dp[i-1] &lt; a<sub>j</sub>的话，就用dp[i] = min(dp[i], a<sub>j</sub>)进行更新。最终找出使dp[i] &lt; INF的最大的i+1就是结果了。而这个dp数组是单调递增的，所以可以知道对于每个a<sub>j</sub>最多只需要更新一次。对于这次更新应该在什么位置，不必逐个遍历，可直接使用二分搜索。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int dp[MAX_N];</span><br><span class="line"></span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">fill(dp, dp + n, INF);</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">*lower_bound(dp, dp+n, a[i]) = a[i];  </span><br><span class="line">//lower_bound(a, a+n, k)函数从已排好序的序列a中利用二分搜索指出满足ai &gt;= k的ai的最小的指针 </span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, lower_bound(dp, dp+n, INF) - dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法的缺点是求最长上升子序列的长度比较快，但最长上升子序列实际是什么很难知道。</p><h2 id="转化为求LCS（时间复杂度O-n2-）"><a href="#转化为求LCS（时间复杂度O-n2-）" class="headerlink" title="转化为求LCS（时间复杂度O(n2)）"></a>转化为求LCS（时间复杂度O(n<sup>2</sup>)）</h2></li><li>可将<strong>所求序列</strong>与<strong>所求序列排序后得到的序列</strong>求最长公共子序列，所得的最长公共子序列即是原序列的最长上升子序列。</li><li>代码可参考LCS的求解代码。</li></ul><p>参考博客：</p><p><a href="https://www.cnblogs.com/handsomecui/p/4692350.html" target="_blank" rel="noopener">handsomecui的博客</a></p><p><a href="https://blog.csdn.net/xws117/article/details/45438917" target="_blank" rel="noopener">xws117123的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数独求解</title>
      <link href="/2018/08/11/%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/08/11/%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>数独问题的求解：深度优先搜索算法以及剪枝<br><a id="more"></a></p><ul><li>对于数独问题的求解，首先考虑从左上角的空白格子开始填数字的深度优先搜索，所填的数字应该是所在行，列和方格中都没有填过的数字，可按此种方法进行减枝。但是对于空白格子多的情况，此种方法可能会超时。</li><li>考虑处理某一行时，对于某个还没用过的数字，如果该行只有一个可行的空白格子，就只能将该数填入该格子中。对于列和方块也一样。反之，如果某个格子可填的数字只有一个，也只能将该数字填入格子。这样，我们优先处理数字或格子唯一的情况。此外，如果搜索过程中发现没有可选的数字或格子这样矛盾的情况，则提前停止搜索。</li><li>但是当没有唯一确定的数字和格子时，此时的搜索又会回到原来从左上的空白格子开始填数字的方法。<strong>当人们求解数独问题时，是不会特地特地这样做的，通常会选择先处理选择少的格子</strong>。</li><li>例如，假设有一个只有五个候选数字的格子，即使其中一个出现了矛盾，依然还有四个候选数字需要尝试。也就是说，比起从左上角开始填数字，<strong>优先选择候选数字少的格子填数字要更加高效</strong>。<h1 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h1></li><li>题面：Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task. </li><li>输入：The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.</li><li>输出：For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them.</li><li>样例输入：<br>1<br>103000509<br>002109400<br>000704000<br>300502006<br>060000050<br>700803004<br>000401000<br>009205800<br>804000107</li><li>样例输出：<br>143628579<br>572139468<br>986754231<br>391542786<br>468917352<br>725863914<br>237481695<br>619275843<br>854396127</li><li>程序代码如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n; </span><br><span class="line">int tag[9][9][9];   //tag[i][j][k]表示(i,j)位置是否可填入数字i+1 </span><br><span class="line">int count[9][9];    //count[i][j]存储(i, j)位置可填入数字的个数 </span><br><span class="line">int s[9][9];         //存储数独矩阵       </span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[i][j] = 9;</span><br><span class="line">for(int k = 0; k &lt; 9; k++)</span><br><span class="line">&#123;</span><br><span class="line">tag[i][j][k] = 0;    //0表示可以放 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input()</span><br><span class="line">&#123;</span><br><span class="line">char str[10];</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;, str);</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">s[i][j] = str[j] -&apos;0&apos;;</span><br><span class="line">if(s[i][j] != 0)</span><br><span class="line">&#123;</span><br><span class="line">//我们最终只关注输入为0的位置的count值，故对于输入的数，其位置所在的count值是不用管的 </span><br><span class="line">for(int a = 0; a &lt; 9; a++)</span><br><span class="line">&#123;</span><br><span class="line">//处理行和列 </span><br><span class="line">if(tag[i][a][s[i][j] -1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[i][a][s[i][j] -1] = 1;   //1表示不能放 </span><br><span class="line">count[i][a]--;</span><br><span class="line">&#125;</span><br><span class="line">if(tag[a][j][s[i][j] - 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[a][j][s[i][j] - 1] = 1;</span><br><span class="line">count[a][j]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//处理其所在的3*3方块 </span><br><span class="line">int area = i / 3 * 3 + j / 3;    //计算方格块的编号 </span><br><span class="line">for(int b = area/3*3; b &lt; area/3*3+3; b++)</span><br><span class="line">&#123;</span><br><span class="line">for(int c = area%3*3; c &lt; area%3*3+3; c++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[b][c][s[i][j] - 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[b][c][s[i][j] - 1] = 1;</span><br><span class="line">count[b][c]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool search(int num)</span><br><span class="line">&#123;</span><br><span class="line">int x, y;</span><br><span class="line">int min = 10;</span><br><span class="line">//printf(&quot;此时num = %d\n&quot;, num);</span><br><span class="line"></span><br><span class="line">//找s[i][j] == 0并且count[i][j]最小的位置 </span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j] == 0 &amp;&amp; min &gt; count[i][j])</span><br><span class="line">&#123;</span><br><span class="line">min = count[i][j];</span><br><span class="line">x = i;</span><br><span class="line">y = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(min == 10)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[x][y][i-1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">s[x][y] = i;</span><br><span class="line">for(int a = 0; a &lt; 9; a++)</span><br><span class="line">&#123;</span><br><span class="line">//行和列 </span><br><span class="line">if(tag[x][a][i-1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[x][a][i-1] = num;</span><br><span class="line">count[x][a]--;</span><br><span class="line">&#125;</span><br><span class="line">if(tag[a][y][i-1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[a][y][i-1] = num;</span><br><span class="line">count[a][y]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//处理其所在的3*3方块 </span><br><span class="line">int area = x / 3 * 3 + y / 3;    //计算方格快的编号 </span><br><span class="line">for(int b = area/3*3; b &lt; area/3*3+3; b++)</span><br><span class="line">&#123;</span><br><span class="line">for(int c = area%3*3; c &lt; area%3*3+3; c++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[b][c][i - 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">tag[b][c][i - 1] = num;</span><br><span class="line">count[b][c]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">             </span><br><span class="line">int result = search(num + 1);</span><br><span class="line">if(result == 1)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s[x][y] = 0;</span><br><span class="line">for(int a = 0; a &lt; 9; a++)</span><br><span class="line">&#123;</span><br><span class="line">//行和列 </span><br><span class="line">if(tag[x][a][i-1] == num)</span><br><span class="line">&#123;</span><br><span class="line">tag[x][a][i-1] = 0;</span><br><span class="line">count[x][a]++;</span><br><span class="line">&#125;</span><br><span class="line">if(tag[a][y][i-1] == num)</span><br><span class="line">&#123;</span><br><span class="line">tag[a][y][i-1] = 0;</span><br><span class="line">count[a][y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">area = x / 3 * 3 + y / 3;    //计算方格快的编号 </span><br><span class="line">for(int b = area/3*3; b &lt; area/3*3+3; b++)</span><br><span class="line">&#123;</span><br><span class="line">for(int c = area%3*3; c &lt; area%3*3+3; c++)</span><br><span class="line">&#123;</span><br><span class="line">if(tag[b][c][i - 1] == num)</span><br><span class="line">&#123;</span><br><span class="line">tag[b][c][i - 1] = 0;</span><br><span class="line">count[b][c]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 9; j++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;, s[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">input();</span><br><span class="line">search(2);</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c++之string类简述</title>
      <link href="/2018/07/30/c++%E4%B9%8Bstring%E7%B1%BB%E7%AE%80%E8%BF%B0/"/>
      <url>/2018/07/30/c++%E4%B9%8Bstring%E7%B1%BB%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>最近在学了C++之后，感觉其中字符串处理涉及到了很多的方法，故将其整理下来，并将其中某些与C语言处理字符串的方法进行对比。<br><a id="more"></a><br>可能是由于受c语言的影响，现在好多时候写题还是用char数组字符串比较多，不过感觉用起来似乎比较麻烦，就决定整理一下<strong>c++中的string类的用法</strong>。</p><h1 id="声明一个C-字符串"><a href="#声明一个C-字符串" class="headerlink" title="声明一个C++字符串"></a>声明一个C++字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br></pre></td></tr></table></figure><ul><li>这样就声明了一个字符串变量<strong>str</strong>,由于其构造函数没有传入参数，故此时将str初始化为一个<strong>空字符串</strong>。<h2 id="string类中的构造函数和析构函数如下："><a href="#string类中的构造函数和析构函数如下：" class="headerlink" title="string类中的构造函数和析构函数如下："></a>string类中的构造函数和析构函数如下：</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s; //生成一个空字符串s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(str); //拷贝构造函数，将str复制到s中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(str, stridx); //将字符串str内**始于位置stridx**的部分当作字符串的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(str, stridx, strlen); //将字符串str内**始于stridx且长度至多为strlen**的部分作为字符串的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(cstr); //将c字符串作为s的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(chars, chars_len); //将c字符串前的至多chars_len个字符串作为字符串s的初值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s(num, c); //生成一个字符串，包含num个c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.~string(); //销毁所有字符，释放内存</span><br></pre></td></tr></table></figure><h1 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h1><ul><li>=，aasign()   //赋值 </li><li>swap()    //交换两个字符串的内容，既可以用作成员函数也可以用作普通函数</li><li>+=,append(),push_back()  //在尾部添加字符，前两个也可添加字符串，后一个只能添加字符</li><li>insert()   //插入字符，有两个参数</li><li>erase()    //删除字符</li><li>clear()    //删除全部字符</li><li>replace()  //替换字符，可将字符串的某段替换为其他字符串</li><li><code>+</code>   //字符串拼接</li><li>==, !=, &lt;, &lt;=, &gt;, &gt;=, compare()     //字符串比较</li><li>size(), length()   //返回字符串中的字符数量，<strong>注意如果求字符数组的长度的话可以用strlen()函数</strong></li><li>max_size()     //返回字符的可能最大个数</li><li>empty()     //判断字符串是否为空</li><li>capacity()   //返回重新分配之前的字符容量</li><li>reverse()   //字符串转置，<strong>注意如果是用字符数组表示字符串的话可用strrev()函数来进行字符串转置</strong></li><li>[],at()    //存取单一字符串</li><li>getline()   //从输入流读入一行</li><li>copy(p,n,size_type _Off = 0)   //从string类型对象中至多复制n个字符到字符指针p指向的空间中。默认从首字符开始，但是也可以指定，开始的位置（记住从0开始）。返回真正从对象中复制的字符。<strong>用户要确保p指向的空间足够保存n个字符</strong>。</li><li>c_str()   //取得c风格的<code>const char *</code>字符串，如果要用scanf()输入或者用printf()输出string类型的变量，我们可以使用c_str()函数，得到string类型的等效字符数组，然后就可以用scanf()/printf()函数进行输入输出。</li><li>data()    //取得字符串内容的地址</li><li>substr()   //返回某个子字符串</li><li>begin()    //得到指向字符串开头的iterator</li><li>end()      //得到指向字符串结尾的iterator</li><li>rbegin()    //得到指向反向字符串开头的iterator</li><li>rend()      //得到指向反向字符串结尾的iterator</li><li>find_first_of()     //查找包含子串中的任何字符，返回第一个位置</li><li>find_first_not_of()     //查找不包含子串中的任何字符，返回第一个位置</li><li>find_last_of()    //查找包含子串中的任何字符，返回最后一个位置</li><li>find_last_not_of()    //查找不包含子串中的任何字符，返回最后一个位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>输入输出流对象</title>
      <link href="/2018/04/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/04/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>C++中的输入输出流,以及一些有限定条件的输入输出方法。<br><a id="more"></a><br>哈哈，今天终于开始更新博客了(<em>^▽^</em>)一时不知道写什么好，就写一下最近学到的东西吧！</p><h1 id="输出流与输入流"><a href="#输出流与输入流" class="headerlink" title="输出流与输入流"></a>输出流与输入流</h1><ul><li><strong>cout</strong>是一个输出流对象，它是“console out”(控制台输出)的缩写,又称为插入运算符，是输出数据的，是属于basic_ostream类中的对象。而ostream类在iostream头文件中定义。</li><li><strong>cin</strong>是一个输入流对象，又称为提取操作符，用来获取用户外部输入的数据，当用户进行键盘输入时，对应的字符将输入到操作系统的键盘缓冲区，当用户点击”Enter”键时，操作系统把键盘缓冲区的内容传输到cin流的内部缓冲区，<strong>“&gt;&gt;”</strong>操作符随后从这个缓冲区提取需要的信息，它是属于istream类中的对象。</li><li>在C++中左移，右移操作符进行了重载。</li><li><p>下面列举一些<strong>cin</strong>和<strong>cout</strong>的用法:</p><h2 id="cin-ignore-amp-cin-getline"><a href="#cin-ignore-amp-cin-getline" class="headerlink" title="cin.ignore() &amp; cin.getline()"></a>cin.ignore() &amp; cin.getline()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[20];</span><br><span class="line">cin.ignore(7);</span><br><span class="line">cin.getline( buf, 10 );</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>使用cin.ignore(7)在输入时会忽略输入的前7个字符。</p></li><li>使用cin.getline（buf, 10）在输入时只会得到前10个字符，注意这10个字符中还要包括’/0’。</li></ul><h2 id="cin-peek-amp-cin-get"><a href="#cin-peek-amp-cin-get" class="headerlink" title="cin.peek() &amp; cin.get()"></a>cin.peek() &amp; cin.get()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char p;</span><br><span class="line">cout &lt;&lt; &quot;请输入一段文本: \n&quot;;</span><br><span class="line">while( cin.peek() != &apos;\n&apos; )</span><br><span class="line">&#123;</span><br><span class="line">      p = cin.get();</span><br><span class="line">      cout &lt;&lt; p;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>cin.peek()函数的返回值是一个<strong>char</strong>型的字符，其返回值是指针指向的当前字符。</li><li>cin.get()函数用来从指定的输入流中提取一个字符(包括空白字符)，函数的返回值就是读入的字符。</li></ul><h2 id="cin-gcount-amp-cin-read"><a href="#cin-gcount-amp-cin-read" class="headerlink" title="cin.gcount() &amp; cin.read()"></a>cin.gcount() &amp; cin.read()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int SIZE = 50;</span><br><span class="line">char buf[SIZE];</span><br><span class="line">cout &lt;&lt; &quot;请输入一段文本: &quot;;</span><br><span class="line">cin.read( buf, 20 );</span><br><span class="line">cout &lt;&lt; &quot;字符串收集到的字符数为: &quot; &lt;&lt; cin.gcount() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;输入的文本信息是: &quot;;</span><br><span class="line">cout.write( buf, 20 );</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>cin.gcount()函数返回一个非格式化的提取方法读取的字符数，这以为着字符是由<strong>cin.get(),cin.getline(),cin.ignore()或cin.read()</strong>函数读取的，不是又提取操作符”&gt;&gt;”读取的。</li><li>cin.read(buf,20)是读取长度为20的字符串给buf字符数组中，该字符串中包括了’\0’。</li></ul><h2 id="cout-precision-amp-cout-width"><a href="#cout-precision-amp-cout-width" class="headerlink" title="cout.precision() &amp; cout.width()"></a>cout.precision() &amp; cout.width()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double result = sqrt(3.0);</span><br><span class="line">cout &lt;&lt; &quot;对 3 开方保留小数点后0 ~ 9 位，结果如下: \n&quot; &lt;&lt;endl;</span><br><span class="line">for( int i=0; i &lt;= 9; i++ )</span><br><span class="line">&#123;</span><br><span class="line">     cout.precision(i);</span><br><span class="line">     cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;当前的输出精度为: &quot; &lt;&lt; cout.precision() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>cout.precision(i)函数设置当前输出精度为i,输出小数点后<strong>i-1</strong>位，第i位四舍五入。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int width = 4;</span><br><span class="line">char str[20];</span><br><span class="line">cout &lt;&lt; &quot;请输入一段文本: \n&quot;;</span><br><span class="line">cin.width(5);</span><br><span class="line">while( cin &gt;&gt; str )</span><br><span class="line">&#123;</span><br><span class="line">     cout.width(width++);</span><br><span class="line">     cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">     cin.width(5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cin.width(n)读取长度为n的字符，注意最后一个字符为’\0’。</li><li>cout.width(n)设置输出宽度为n，不足的用空格补齐。<h1 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h1></li><li><strong>cout</strong>这个输出流对象是在名字空间<strong>std</strong>中来定义的。</li><li><p>在使用时可以直接用指令<strong>using namespace std</strong>，然后再使用<strong>cout</strong>，或者直接使用<strong>std::cout</strong>。</p><p><code>std::cout&lt;&lt;&quot;This is a test&quot;&lt;&lt;endl</code></p></li></ul><p>第一次写就先写到这了，希望以后自己能坚持下去!ヾ(◍°∇°◍)ﾉﾞ</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
